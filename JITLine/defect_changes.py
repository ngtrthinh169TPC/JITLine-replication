code_changes = [[{"added_code":["[ sdnve ]", "( ListOpt ) The IP address of one ( or more ) SDN - VE controllers", "Default value is : controller _ ips = 127 . 0 . 0 . 1", "Example : controller _ ips = 127 . 0 . 0 . 1 , 127 . 0 . 0 . 2", "( StrOpt ) The integration bridge for OF based implementation", "The default value for integration _ bridge is None", "Example : integration _ bridge = br - int", "( ListOpt ) The interface mapping connecting the integration", "bridge to external network as a list of physical network names and", "interfaces : < physical _ network _ name > : < interface _ name >", "Example : interface _ mappings = default : eth2", "( BoolOpt ) Used to reset the integration bridge , if exists", "The default value for reset _ bridge is True", "Example : reset _ bridge = False", "( BoolOpt ) Used to set the OVS controller as out - of - band", "The default value for out _ of _ band is True", "Example : out _ of _ band = False", "", "( BoolOpt ) The fake controller for testing purposes", "Default value is : use _ fake _ controller = False", "( StrOpt ) The port number for use with controller", "The default value for the port is 8443", "Example : port = 8443", "( StrOpt ) The userid for use with controller", "The default value for the userid is admin", "Example : userid = sdnve _ user", "( StrOpt ) The password for use with controller", "The default value for the password is admin", "Example : password = sdnve _ password", "", "( StrOpt ) The default type of tenants ( and associated resources )", "Default value for OF is : default _ tenant = OF", "Example : default _ tenant = OVERLAY", "( StrOpt ) The string in tenant description that indicates", "Default value for OF tenants : of _ signature = SDNVE - OF", "( StrOpt ) The string in tenant description that indicates", "Default value for OVERLAY tenants : overlay _ signature = SDNVE - OVERLAY", "[ sdnve _ agent ]", "( IntOpt ) Agent ' s polling interval in seconds", "polling _ interval = 2", "( StrOpt ) What to use for root helper", "The default value : root _ helper = ' sudo '", "( BoolOpt ) Whether to use rpc or not", "The default value : rpc = True", "[ securitygroup ]", "The security group is not supported :", "firewall _ driver = neutron . agent . firewall . NoopFirewallDriver", ],"removed_code":[]},{"added_code":["' neutron . plugins . vmware . plugin . NsxServicePlugin ' ,", "' neutron . plugins . ibm . sdnve _ neutron _ plugin . SdnvePluginV2 ' ,", ],"removed_code":["' neutron . plugins . vmware . plugin . NsxServicePlugin '", ]},{"added_code":["' neutron . plugins . ibm . sdnve _ neutron _ plugin . SdnvePluginV2 ' ,", ],"removed_code":[]},{"added_code":["' neutron . services . loadbalancer . plugin . LoadBalancerPlugin ' ,", "' neutron . plugins . ibm . sdnve _ neutron _ plugin . SdnvePluginV2 ' ,", ],"removed_code":["' neutron . services . loadbalancer . plugin . LoadBalancerPlugin '", ]},{"added_code":["' ibm ' : ' neutron . plugins . ibm . sdnve _ neutron _ plugin . SdnvePluginV2 ' ,", "PLUGINS [ ' ibm ' ] ,", ],"removed_code":[]},{"added_code":["IBM SDN - VE Neutron Plugin", "This plugin implements Neutron v2 APIs .", "For more details on how to use it please refer to the following page :", "http : / / wiki . openstack . org / wiki / IBM - Neutron", ],"removed_code":[]},{"added_code":[],"removed_code":[]},{"added_code":[],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "import socket", "import time", "import eventlet", "from oslo . config import cfg", "from neutron . agent . linux import ip _ lib", "from neutron . agent . linux import ovs _ lib", "from neutron . agent import rpc as agent _ rpc", "from neutron . common import config as logging _ config", "from neutron . common import legacy", "from neutron . common import topics", "from neutron . common import utils as q _ utils", "from neutron import context", "from neutron . openstack . common import log as logging", "from neutron . openstack . common . rpc import dispatcher", "from neutron . plugins . ibm . common import config # noqa", "from neutron . plugins . ibm . common import constants", "LOG = logging . getLogger ( _ _ name _ _ )", "class SdnvePluginApi ( agent _ rpc . PluginApi ) :", "def sdnve _ info ( self , context , info ) :", "return self . call ( context ,", "self . make _ msg ( ' sdnve _ info ' , info = info ) ,", "topic = self . topic )", "class SdnveNeutronAgent ( ) :", "RPC _ API _ VERSION = ' 1 . 1 '", "def _ _ init _ _ ( self , integ _ br , interface _ mappings ,", "info , root _ helper , polling _ interval ,", "controller _ ip , reset _ br , out _ of _ band ) :", "' ' ' The agent initialization .", "Sets the following parameters and sets up the integration", "bridge and physical interfaces if need be .", ": param integ _ br : name of the integration bridge .", ": param interface _ mappings : interfaces to physical networks .", ": param info : local IP address of this hypervisor .", ": param root _ helper : utility to use when running shell cmds .", ": param polling _ interval : interval ( secs ) to poll DB .", ": param controller _ ip : Ip address of SDN - VE controller .", "' ' '", "self . root _ helper = root _ helper", "self . int _ bridge _ name = integ _ br", "self . controller _ ip = controller _ ip", "self . interface _ mappings = interface _ mappings", "self . polling _ interval = polling _ interval", "self . info = info", "self . reset _ br = reset _ br", "self . out _ of _ band = out _ of _ band", "if self . int _ bridge _ name :", "self . int _ br = self . setup _ integration _ br ( integ _ br , reset _ br ,", "out _ of _ band ,", "self . controller _ ip )", "self . setup _ physical _ interfaces ( self . interface _ mappings )", "else :", "self . int _ br = None", "self . setup _ rpc ( )", "def setup _ rpc ( self ) :", "if self . int _ br :", "mac = self . int _ br . get _ local _ port _ mac ( )", "self . agent _ id = ' % s % s ' % ( ' sdnve ' , ( mac . replace ( `` : `` , `` `` ) ) )", "else :", "nameaddr = socket . gethostbyname ( socket . gethostname ( ) )", "self . agent _ id = ' % s % s ' % ( ' sdnve _ ' , ( nameaddr . replace ( `` . `` , `` _ `` ) ) )", "self . topic = topics . AGENT", "self . plugin _ rpc = SdnvePluginApi ( topics . PLUGIN )", "self . state _ rpc = agent _ rpc . PluginReportStateAPI ( topics . PLUGIN )", "self . context = context . get _ admin _ context _ without _ session ( )", "self . dispatcher = self . create _ rpc _ dispatcher ( )", "consumers = [ [ constants . INFO , topics . UPDATE ] ]", "self . connection = agent _ rpc . create _ consumers ( self . dispatcher ,", "self . topic ,", "consumers )", "# Plugin calls the agents through the following", "def info _ update ( self , context , * * kwargs ) :", "LOG . debug ( _ ( `` info _ update received `` ) )", "info = kwargs . get ( ' info ' , { } )", "new _ controller = info . get ( ' new _ controller ' )", "out _ of _ band = info . get ( ' out _ of _ band ' )", "if self . int _ br and new _ controller :", "LOG . debug ( _ ( `` info _ update received . New controller ``", "`` is to be set to : % s `` ) , new _ controller )", "self . int _ br . run _ vsctl ( [ `` set - controller `` ,", "self . int _ bridge _ name ,", "`` tcp : `` + new _ controller ] )", "if out _ of _ band :", "LOG . debug ( _ ( `` info _ update received . New controller ``", "`` is set to be out of band `` ) )", "self . int _ br . set _ db _ attribute ( `` controller `` ,", "self . int _ bridge _ name ,", "`` connection - mode `` ,", "`` out - of - band `` )", "def create _ rpc _ dispatcher ( self ) :", "return dispatcher . RpcDispatcher ( [ self ] )", "def setup _ integration _ br ( self , bridge _ name , reset _ br , out _ of _ band ,", "controller _ ip = None ) :", "' ' ' Sets up the integration bridge .", "Create the bridge and remove all existing flows if reset _ br is True .", "Otherwise , creates the bridge if not already existing .", ": param bridge _ name : the name of the integration bridge .", ": param reset _ br : A boolean to rest the bridge if True .", ": param out _ of _ band : A boolean inidicating controller is out of band .", ": param controller _ ip : IP address to use as the bridge controller .", ": returns : the integration bridge", "' ' '", "int _ br = ovs _ lib . OVSBridge ( bridge _ name , self . root _ helper )", "if reset _ br :", "int _ br . reset _ bridge ( )", "int _ br . remove _ all _ flows ( )", "else :", "int _ br . create ( )", "# set the controller", "if controller _ ip :", "int _ br . run _ vsctl (", "[ `` set - controller `` , bridge _ name , `` tcp : `` + controller _ ip ] )", "if out _ of _ band :", "int _ br . set _ db _ attribute ( `` controller `` , bridge _ name ,", "`` connection - mode `` , `` out - of - band `` )", "return int _ br", "def setup _ physical _ interfaces ( self , interface _ mappings ) :", "' ' ' Sets up the physical network interfaces .", "Link physical interfaces to the integration bridge .", ": param interface _ mappings : map physical net names to interface names .", "' ' '", "for physical _ network , interface in interface _ mappings . iteritems ( ) :", "LOG . info ( _ ( `` Mapping physical network % ( physical _ network ) s to ``", "`` interface % ( interface ) s `` ) ,", "{ ' physical _ network ' : physical _ network ,", "' interface ' : interface } )", "# Connect the physical interface to the bridge", "if not ip _ lib . device _ exists ( interface , self . root _ helper ) :", "LOG . error ( _ ( `` Interface % ( interface ) s for physical network ``", "`` % ( physical _ network ) s does not exist . Agent ``", "`` terminated ! `` ) ,", "{ ' physical _ network ' : physical _ network ,", "' interface ' : interface } )", "raise SystemExit ( 1 )", "self . int _ br . add _ port ( interface )", "def sdnve _ info ( self ) :", "details = self . plugin _ rpc . sdnve _ info (", "self . context ,", "{ ' info ' : self . info } )", "return details", "def rpc _ loop ( self ) :", "while True :", "start = time . time ( )", "LOG . debug ( _ ( `` Agent in the rpc loop . `` ) )", "# sleep till end of polling interval", "elapsed = ( time . time ( ) - start )", "if ( elapsed < self . polling _ interval ) :", "time . sleep ( self . polling _ interval - elapsed )", "else :", "LOG . info ( _ ( `` Loop iteration exceeded interval ``", "`` ( % ( polling _ interval ) s vs . % ( elapsed ) s ) ! `` ) ,", "{ ' polling _ interval ' : self . polling _ interval ,", "' elapsed ' : elapsed } )", "def daemon _ loop ( self ) :", "self . rpc _ loop ( )", "def create _ agent _ config _ map ( config ) :", "interface _ mappings = q _ utils . parse _ mappings (", "config . SDNVE . interface _ mappings )", "controller _ ips = config . SDNVE . controller _ ips", "LOG . info ( _ ( `` Controller IPs : % s `` ) , controller _ ips )", "controller _ ip = controller _ ips [ 0 ]", "return {", "' integ _ br ' : config . SDNVE . integration _ bridge ,", "' interface _ mappings ' : interface _ mappings ,", "' controller _ ip ' : controller _ ip ,", "' info ' : config . SDNVE . info ,", "' root _ helper ' : config . SDNVE _ AGENT . root _ helper ,", "' polling _ interval ' : config . SDNVE _ AGENT . polling _ interval ,", "' reset _ br ' : config . SDNVE . reset _ bridge ,", "' out _ of _ band ' : config . SDNVE . out _ of _ band }", "def main ( ) :", "eventlet . monkey _ patch ( )", "cfg . CONF . register _ opts ( ip _ lib . OPTS )", "cfg . CONF ( project = ' neutron ' )", "logging _ config . setup _ logging ( cfg . CONF )", "legacy . modernize _ quantum _ config ( cfg . CONF )", "try :", "agent _ config = create _ agent _ config _ map ( cfg . CONF )", "except ValueError as e :", "LOG . exception ( _ ( `` % s Agent terminated ! `` ) , e )", "raise SystemExit ( 1 )", "plugin = SdnveNeutronAgent ( * * agent _ config )", "# Start everything .", "LOG . info ( _ ( `` Agent initialized successfully , now running . . . `` ) )", "plugin . daemon _ loop ( )", ],"removed_code":[]},{"added_code":[],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "from oslo . config import cfg", "DEFAULT _ INTERFACE _ MAPPINGS = [ ]", "DEFAULT _ CONTROLLER _ IPS = [ ' 127 . 0 . 0 . 1 ' ]", "sdnve _ opts = [", "cfg . BoolOpt ( ' use _ fake _ controller ' , default = False ,", "help = _ ( `` If set to True uses a fake controller . `` ) ) ,", "cfg . StrOpt ( ' base _ url ' , default = ' / one / nb / v2 / ' ,", "help = _ ( `` Base URL for SDN - VE controller REST API `` ) ) ,", "cfg . ListOpt ( ' controller _ ips ' , default = DEFAULT _ CONTROLLER _ IPS ,", "help = _ ( `` List of IP addresses of SDN - VE controller ( s ) `` ) ) ,", "cfg . StrOpt ( ' info ' , default = ' sdnve _ info _ string ' ,", "help = _ ( `` SDN - VE RPC subject `` ) ) ,", "cfg . StrOpt ( ' port ' , default = ' 8443 ' ,", "help = _ ( `` SDN - VE controller port number `` ) ) ,", "cfg . StrOpt ( ' format ' , default = ' json ' ,", "help = _ ( `` SDN - VE request / response format `` ) ) ,", "cfg . StrOpt ( ' userid ' , default = ' admin ' ,", "help = _ ( `` SDN - VE administrator user id `` ) ) ,", "cfg . StrOpt ( ' password ' , default = ' admin ' ,", "help = _ ( `` SDN - VE administrator password `` ) ) ,", "cfg . StrOpt ( ' integration _ bridge ' , default = None ,", "help = _ ( `` Integration bridge to use `` ) ) ,", "cfg . BoolOpt ( ' reset _ bridge ' , default = True ,", "help = _ ( `` Reset the integration bridge before use `` ) ) ,", "cfg . BoolOpt ( ' out _ of _ band ' , default = True ,", "help = _ ( `` Indicating if controller is out of band or not `` ) ) ,", "cfg . ListOpt ( ' interface _ mappings ' ,", "default = DEFAULT _ INTERFACE _ MAPPINGS ,", "help = _ ( `` List of < physical _ network _ name > : < interface _ name > `` ) ) ,", "cfg . StrOpt ( ' default _ tenant _ type ' , default = ' OF ' ,", "help = _ ( `` Tenant type : OF ( default ) and OVERLAY `` ) ) ,", "cfg . StrOpt ( ' overlay _ signature ' , default = ' SDNVE - OVERLAY ' ,", "help = _ ( `` The string in tenant description that indicates ``", "`` the tenant is a OVERLAY tenant `` ) ) ,", "cfg . StrOpt ( ' of _ signature ' , default = ' SDNVE - OF ' ,", "help = _ ( `` The string in tenant description that indicates ``", "`` the tenant is a OF tenant `` ) ) ,", "]", "sdnve _ agent _ opts = [", "cfg . IntOpt ( ' polling _ interval ' , default = 2 ,", "help = _ ( `` Agent polling interval if necessary `` ) ) ,", "cfg . StrOpt ( ' root _ helper ' , default = ' sudo ' ,", "help = _ ( `` Using root helper `` ) ) ,", "cfg . BoolOpt ( ' rpc ' , default = True ,", "help = _ ( `` Whether using rpc `` ) ) ,", "]", "cfg . CONF . register _ opts ( sdnve _ opts , `` SDNVE `` )", "cfg . CONF . register _ opts ( sdnve _ agent _ opts , `` SDNVE _ AGENT `` )", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "import httplib", "Topic for info notifications between the plugin and agent", "INFO = ' info '", "TENANT _ TYPE _ OF = ' OF '", "TENANT _ TYPE _ OVERLAY = ' OVERLAY '", "HTTP _ ACCEPTABLE = [ httplib . OK ,", "httplib . CREATED ,", "httplib . ACCEPTED ,", "httplib . NO _ CONTENT", "]", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "from neutron . common import exceptions", "class SdnveException ( exceptions . NeutronException ) :", "message = _ ( `` An unexpected error occurred in the SDN - VE Plugin . ``", "`` Here is the error message : % ( msg ) s `` )", "class BadInputException ( exceptions . BadRequest ) :", "message = _ ( `` The input does not contain nececessary info : % ( msg ) s `` )", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "import httplib", "import urllib", "import httplib2", "from keystoneclient . v2 _ 0 import client as keyclient", "from oslo . config import cfg", "from neutron . api . v2 import attributes", "from neutron . openstack . common import log as logging", "from neutron . plugins . ibm . common import config # noqa", "from neutron . plugins . ibm . common import constants", "from neutron . wsgi import Serializer", "LOG = logging . getLogger ( _ _ name _ _ )", "SDNVE _ VERSION = ' 2 . 0 '", "SDNVE _ ACTION _ PREFIX = ' / sdnve '", "SDNVE _ RETRIES = 0", "SDNVE _ RETRIY _ INTERVAL = 1", "SDNVE _ TENANT _ TYPE _ OVERLAY = u ' DOVE '", "SDNVE _ URL = ' https : / / % s : % s % s '", "class RequestHandler ( object ) :", "' ' ' Handles processeing requests to and responses from controller . ' ' '", "def _ _ init _ _ ( self , controller _ ips = None , port = None , ssl = None ,", "base _ url = None , userid = None , password = None ,", "timeout = 10 , formats = None ) :", "' ' ' Initializes the RequestHandler for communication with controller", "Following keyword arguments are used ; if not specified , default", "values are used .", ": param port : Username for authentication .", ": param timeout : Time out for http requests .", ": param userid : User id for accessing controller .", ": param password : Password for accessing the controlelr .", ": param base _ url : The base url for the controller .", ": param controller _ ips : List of controller IP addresses .", ": param formats : Supported formats .", "' ' '", "self . port = port or cfg . CONF . SDNVE . port", "self . timeout = timeout", "self . _ s _ meta = None", "self . connection = None", "self . httpclient = httplib2 . Http (", "disable _ ssl _ certificate _ validation = True )", "self . cookie = None", "userid = userid or cfg . CONF . SDNVE . userid", "password = password or cfg . CONF . SDNVE . password", "if ( userid and password ) :", "self . httpclient . add _ credentials ( userid , password )", "self . base _ url = base _ url or cfg . CONF . SDNVE . base _ url", "self . controller _ ips = controller _ ips or cfg . CONF . SDNVE . controller _ ips", "LOG . info ( _ ( `` The IP addr of available SDN - VE controllers : % s `` ) ,", "self . controller _ ips )", "self . controller _ ip = self . controller _ ips [ 0 ]", "LOG . info ( _ ( `` The SDN - VE controller IP address : % s `` ) ,", "self . controller _ ip )", "self . new _ controller = False", "self . format = formats or cfg . CONF . SDNVE . format", "self . version = SDNVE _ VERSION", "self . action _ prefix = SDNVE _ ACTION _ PREFIX", "self . retries = SDNVE _ RETRIES", "self . retry _ interval = SDNVE _ RETRIY _ INTERVAL", "def serialize ( self , data ) :", "' ' ' Serializes a dictionary with a single key . ' ' '", "if isinstance ( data , dict ) :", "return Serializer ( ) . serialize ( data , self . content _ type ( ) )", "elif data :", "raise TypeError ( _ ( `` unable to serialize object type : ' % s ' `` ) %", "type ( data ) )", "def deserialize ( self , data , status _ code ) :", "' ' ' Deserializes an xml or json string into a dictionary . ' ' '", "# NOTE ( mb ) : Temporary fix for backend controller requirement", "data = data . replace ( `` router _ external `` , `` router : external `` )", "if status _ code = = httplib . NO _ CONTENT :", "return data", "try :", "deserialized _ data = Serializer (", "metadata = self . _ s _ meta ) . deserialize ( data , self . content _ type ( ) )", "deserialized _ data = deserialized _ data [ ' body ' ]", "except Exception :", "deserialized _ data = data", "return deserialized _ data", "def content _ type ( self , format = None ) :", "' ' ' Returns the mime - type for either ' xml ' or ' json ' . ' ' '", "return ' application / % s ' % ( format or self . format )", "def delete ( self , url , body = None , headers = None , params = None ) :", "return self . do _ request ( `` DELETE `` , url , body = body ,", "headers = headers , params = params )", "def get ( self , url , body = None , headers = None , params = None ) :", "return self . do _ request ( `` GET `` , url , body = body ,", "headers = headers , params = params )", "def post ( self , url , body = None , headers = None , params = None ) :", "return self . do _ request ( `` POST `` , url , body = body ,", "headers = headers , params = params )", "def put ( self , url , body = None , headers = None , params = None ) :", "return self . do _ request ( `` PUT `` , url , body = body ,", "headers = headers , params = params )", "def do _ request ( self , method , url , body = None , headers = None ,", "params = None , connection _ type = None ) :", "status _ code = - 1", "replybody _ deserialized = ' '", "if body :", "body = self . serialize ( body )", "self . headers = headers or { ' Content - Type ' : self . content _ type ( ) }", "if self . cookie :", "self . headers [ ' cookie ' ] = self . cookie", "if self . controller _ ip ! = self . controller _ ips [ 0 ] :", "controllers = [ self . controller _ ip ]", "else :", "controllers = [ ]", "controllers . extend ( self . controller _ ips )", "for controller _ ip in controllers :", "serverurl = SDNVE _ URL % ( controller _ ip , self . port , self . base _ url )", "myurl = serverurl + url", "if params and isinstance ( params , dict ) :", "myurl + = ' ? ' + urllib . urlencode ( params , doseq = 1 )", "try :", "LOG . debug ( _ ( `` Sending request to SDN - VE . url : ``", "`` % ( myurl ) s method : % ( method ) s body : ``", "`` % ( body ) s header : % ( header ) s `` ) ,", "{ ' myurl ' : myurl , ' method ' : method ,", "' body ' : body , ' header ' : self . headers } )", "resp , replybody = self . httpclient . request (", "myurl , method = method , body = body , headers = self . headers )", "LOG . debug ( ( `` Response recd from SDN - VE . resp : % ( resp ) s ``", "`` body : % ( body ) s `` ) ,", "{ ' resp ' : resp . status , ' body ' : replybody } )", "status _ code = resp . status", "except Exception as e :", "LOG . error ( _ ( `` Error : Could not reach server : % ( url ) s ``", "`` Exception : % ( excp ) s . `` ) ,", "{ ' url ' : myurl , ' excp ' : e } )", "self . cookie = None", "continue", "if status _ code not in constants . HTTP _ ACCEPTABLE :", "LOG . debug ( _ ( `` Error message : % ( reply ) s - - Status : % ( status ) s `` ) ,", "{ ' reply ' : replybody , ' status ' : status _ code } )", "else :", "LOG . debug ( _ ( `` Received response status : % s `` ) , status _ code )", "if resp . get ( ' set - cookie ' ) :", "self . cookie = resp [ ' set - cookie ' ]", "replybody _ deserialized = self . deserialize (", "replybody ,", "status _ code )", "LOG . debug ( _ ( `` Deserialized body : % s `` ) , replybody _ deserialized )", "if controller _ ip ! = self . controller _ ip :", "# bcast the change of controller", "self . new _ controller = True", "self . controller _ ip = controller _ ip", "return ( status _ code , replybody _ deserialized )", "return ( httplib . REQUEST _ TIMEOUT , ' Could not reach server ( s ) ' )", "class Client ( RequestHandler ) :", "' ' ' Client for SDNVE controller . ' ' '", "def _ _ init _ _ ( self ) :", "' ' ' Initialize a new SDNVE client . ' ' '", "super ( Client , self ) . _ _ init _ _ ( )", "self . keystoneclient = KeystoneClient ( )", "resource _ path = {", "' network ' : `` ln / networks / `` ,", "' subnet ' : `` ln / subnets / `` ,", "' port ' : `` ln / ports / `` ,", "' tenant ' : `` ln / tenants / `` ,", "' router ' : `` ln / routers / `` ,", "' floatingip ' : `` ln / floatingips / `` ,", "}", "def process _ request ( self , body ) :", "' ' ' Processes requests according to requirements of controller . ' ' '", "if self . format = = ' json ' :", "body = dict (", "( k . replace ( ' : ' , ' _ ' ) , v ) for k , v in body . items ( )", "if attributes . is _ attr _ set ( v ) )", "def sdnve _ list ( self , resource , * * params ) :", "' ' ' Fetches a list of resources . ' ' '", "res = self . resource _ path . get ( resource , None )", "if not res :", "LOG . info ( _ ( `` Bad resource for forming a list request `` ) )", "return 0 , ' '", "return self . get ( res , params = params )", "def sdnve _ show ( self , resource , specific , * * params ) :", "' ' ' Fetches information of a certain resource . ' ' '", "res = self . resource _ path . get ( resource , None )", "if not res :", "LOG . info ( _ ( `` Bad resource for forming a show request `` ) )", "return 0 , ' '", "return self . get ( res + specific , params = params )", "def sdnve _ create ( self , resource , body ) :", "' ' ' Creates a new resource . ' ' '", "res = self . resource _ path . get ( resource , None )", "if not res :", "LOG . info ( _ ( `` Bad resource for forming a create request `` ) )", "return 0 , ' '", "self . process _ request ( body )", "status , data = self . post ( res , body = body )", "return ( status , data )", "def sdnve _ update ( self , resource , specific , body = None ) :", "' ' ' Updates a resource . ' ' '", "res = self . resource _ path . get ( resource , None )", "if not res :", "LOG . info ( _ ( `` Bad resource for forming a update request `` ) )", "return 0 , ' '", "self . process _ request ( body )", "return self . put ( res + specific , body = body )", "def sdnve _ delete ( self , resource , specific ) :", "' ' ' Deletes the specified resource . ' ' '", "res = self . resource _ path . get ( resource , None )", "if not res :", "LOG . info ( _ ( `` Bad resource for forming a delete request `` ) )", "return 0 , ' '", "return self . delete ( res + specific )", "def _ tenant _ id _ conversion ( self , osid ) :", "return osid", "def sdnve _ get _ tenant _ byid ( self , os _ tenant _ id ) :", "sdnve _ tenant _ id = self . _ tenant _ id _ conversion ( os _ tenant _ id )", "resp , content = self . sdnve _ show ( ' tenant ' , sdnve _ tenant _ id )", "if resp in constants . HTTP _ ACCEPTABLE :", "tenant _ id = content . get ( ' id ' )", "tenant _ type = content . get ( ' network _ type ' )", "if tenant _ type = = SDNVE _ TENANT _ TYPE _ OVERLAY :", "tenant _ type = constants . TENANT _ TYPE _ OVERLAY", "return tenant _ id , tenant _ type", "return None , None", "def sdnve _ check _ and _ create _ tenant ( self , os _ tenant _ id , network _ type = None ) :", "if not os _ tenant _ id :", "return", "tenant _ id , tenant _ type = self . sdnve _ get _ tenant _ byid ( os _ tenant _ id )", "if tenant _ id :", "if not network _ type :", "return tenant _ id", "if tenant _ type ! = network _ type :", "LOG . info ( _ ( `` Non matching tenant and network types : ``", "`` % ( ttype ) s % ( ntype ) s `` ) ,", "{ ' ttype ' : tenant _ type , ' ntype ' : network _ type } )", "return", "return tenant _ id", "# Have to create a new tenant", "sdnve _ tenant _ id = self . _ tenant _ id _ conversion ( os _ tenant _ id )", "if not network _ type :", "network _ type = self . keystoneclient . get _ tenant _ type ( os _ tenant _ id )", "if network _ type = = constants . TENANT _ TYPE _ OVERLAY :", "network _ type = SDNVE _ TENANT _ TYPE _ OVERLAY", "pinn _ desc = ( `` Created by SDN - VE Neutron Plugin , OS project name = `` +", "self . keystoneclient . get _ tenant _ name ( os _ tenant _ id ) )", "res , content = self . sdnve _ create ( ' tenant ' ,", "{ ' id ' : sdnve _ tenant _ id ,", "' name ' : os _ tenant _ id ,", "' network _ type ' : network _ type ,", "' description ' : pinn _ desc } )", "if res not in constants . HTTP _ ACCEPTABLE :", "return", "return sdnve _ tenant _ id", "def sdnve _ get _ controller ( self ) :", "if self . new _ controller :", "self . new _ controller = False", "return self . controller _ ip", "class KeystoneClient ( object ) :", "def _ _ init _ _ ( self , username = None , tenant _ name = None , password = None ,", "auth _ url = None ) :", "keystone _ conf = cfg . CONF . keystone _ authtoken", "keystone _ auth _ url = ( ' % s : / / % s : % s / v2 . 0 / ' %", "( keystone _ conf . auth _ protocol ,", "keystone _ conf . auth _ host ,", "keystone _ conf . auth _ port ) )", "username = username or keystone _ conf . admin _ user", "tenant _ name = tenant _ name or keystone _ conf . admin _ tenant _ name", "password = password or keystone _ conf . admin _ password", "auth _ url = auth _ url or keystone _ auth _ url", "self . overlay _ signature = cfg . CONF . SDNVE . overlay _ signature", "self . of _ signature = cfg . CONF . SDNVE . of _ signature", "self . default _ tenant _ type = cfg . CONF . SDNVE . default _ tenant _ type", "self . client = keyclient . Client ( username = username ,", "password = password ,", "tenant _ name = tenant _ name ,", "auth _ url = auth _ url )", "def get _ tenant _ byid ( self , id ) :", "try :", "return self . client . tenants . get ( id )", "except Exception :", "LOG . exception ( _ ( `` Did not find tenant : % r `` ) , id )", "def get _ tenant _ type ( self , id ) :", "tenant = self . get _ tenant _ byid ( id )", "if tenant :", "description = tenant . description", "if description :", "if ( description . find ( self . overlay _ signature ) > = 0 ) :", "return constants . TENANT _ TYPE _ OVERLAY", "if ( description . find ( self . of _ signature ) > = 0 ) :", "return constants . TENANT _ TYPE _ OF", "return self . default _ tenant _ type", "def get _ tenant _ name ( self , id ) :", "tenant = self . get _ tenant _ byid ( id )", "if tenant :", "return tenant . name", "return ' not found '", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "from neutron . openstack . common import log as logging", "from neutron . plugins . ibm . common import constants", "LOG = logging . getLogger ( _ _ name _ _ )", "HTTP _ OK = 200", "class FakeClient ( ) :", "' ' ' Fake Client for SDNVE controller . ' ' '", "def _ _ init _ _ ( self , * * kwargs ) :", "LOG . info ( _ ( ' Fake SDNVE controller initialized ' ) )", "def sdnve _ list ( self , resource , * * _ params ) :", "LOG . info ( _ ( ' Fake SDNVE controller : list ' ) )", "return ( HTTP _ OK , None )", "def sdnve _ show ( self , resource , specific , * * _ params ) :", "LOG . info ( _ ( ' Fake SDNVE controller : show ' ) )", "return ( HTTP _ OK , None )", "def sdnve _ create ( self , resource , body ) :", "LOG . info ( _ ( ' Fake SDNVE controller : create ' ) )", "return ( HTTP _ OK , None )", "def sdnve _ update ( self , resource , specific , body = None ) :", "LOG . info ( _ ( ' Fake SDNVE controller : update ' ) )", "return ( HTTP _ OK , None )", "def sdnve _ delete ( self , resource , specific ) :", "LOG . info ( _ ( ' Fake SDNVE controller : delete ' ) )", "return ( HTTP _ OK , None )", "def sdnve _ get _ tenant _ byid ( self , id ) :", "LOG . info ( _ ( ' Fake SDNVE controller : get tenant by id ' ) )", "return id , constants . TENANT _ TYPE _ OF", "def sdnve _ check _ and _ create _ tenant ( self , id , network _ type = None ) :", "LOG . info ( _ ( ' Fake SDNVE controller : check and create tenant ' ) )", "return id", "def sdnve _ get _ controller ( self ) :", "LOG . info ( _ ( ' Fake SDNVE controller : get controller ' ) )", "return None", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp .", "import functools", "from oslo . config import cfg", "from neutron . common import constants as q _ const", "from neutron . common import exceptions as q _ exc", "from neutron . common import rpc as q _ rpc", "from neutron . common import topics", "from neutron . db import agents _ db", "from neutron . db import db _ base _ plugin _ v2", "from neutron . db import external _ net _ db", "from neutron . db import l3 _ gwmode _ db", "from neutron . db import portbindings _ db", "from neutron . extensions import portbindings", "from neutron . openstack . common import excutils", "from neutron . openstack . common import log as logging", "from neutron . openstack . common import rpc", "from neutron . openstack . common . rpc import proxy", "from neutron . plugins . ibm . common import config # noqa", "from neutron . plugins . ibm . common import constants", "from neutron . plugins . ibm . common import exceptions as sdnve _ exc", "from neutron . plugins . ibm import sdnve _ api as sdnve", "from neutron . plugins . ibm import sdnve _ api _ fake as sdnve _ fake", "LOG = logging . getLogger ( _ _ name _ _ )", "class SdnveRpcCallbacks ( ) :", "def _ _ init _ _ ( self , notifier ) :", "self . notifier = notifier # used to notify the agent", "def create _ rpc _ dispatcher ( self ) :", "' ' ' Get the rpc dispatcher for this manager .", "If a manager would like to set an rpc API version , or support more than", "one class as the target of rpc messages , override this method .", "' ' '", "return q _ rpc . PluginRpcDispatcher ( [ self ,", "agents _ db . AgentExtRpcCallback ( ) ] )", "def sdnve _ info ( self , rpc _ context , * * kwargs ) :", "' ' ' Update new information . ' ' '", "info = kwargs . get ( ' info ' )", "# Notify all other listening agents", "self . notifier . info _ update ( rpc _ context , info )", "return info", "class AgentNotifierApi ( proxy . RpcProxy ) :", "' ' ' Agent side of the SDN - VE rpc API . ' ' '", "BASE _ RPC _ API _ VERSION = ' 1 . 0 '", "def _ _ init _ _ ( self , topic ) :", "super ( AgentNotifierApi , self ) . _ _ init _ _ (", "topic = topic , default _ version = self . BASE _ RPC _ API _ VERSION )", "self . topic _ info _ update = topics . get _ topic _ name ( topic ,", "constants . INFO ,", "topics . UPDATE )", "def info _ update ( self , context , info ) :", "self . fanout _ cast ( context ,", "self . make _ msg ( ' info _ update ' ,", "info = info ) ,", "topic = self . topic _ info _ update )", "def _ ha ( func ) :", "' ' ' Supports the high availability feature of the controller . ' ' '", "@ functools . wraps ( func )", "def hawrapper ( self , * args , * * kwargs ) :", "' ' ' This wrapper sets the new controller if necessary", "When a controller is detected to be not responding , and a", "new controller is chosen to be used in its place , this decorator", "makes sure the existing integration bridges are set to point", "to the new controleer by calling the set _ controller method .", "' ' '", "ret _ func = func ( self , * args , * * kwargs )", "self . set _ controller ( args [ 0 ] )", "return ret _ func", "return hawrapper", "class SdnvePluginV2 ( db _ base _ plugin _ v2 . NeutronDbPluginV2 ,", "external _ net _ db . External _ net _ db _ mixin ,", "portbindings _ db . PortBindingMixin ,", "l3 _ gwmode _ db . L3 _ NAT _ db _ mixin ,", ") :", "' ' '", "Implement the Neutron abstractions using SDN - VE SDN Controller .", "' ' '", "_ _ native _ bulk _ support = False", "_ _ native _ pagination _ support = False", "_ _ native _ sorting _ support = False", "supported _ extension _ aliases = [ `` binding `` , `` router `` , `` external - net `` ]", "def _ _ init _ _ ( self , configfile = None ) :", "self . base _ binding _ dict = {", "portbindings . VIF _ TYPE : portbindings . VIF _ TYPE _ OVS ,", "portbindings . VIF _ DETAILS : { portbindings . CAP _ PORT _ FILTER : False } }", "super ( SdnvePluginV2 , self ) . _ _ init _ _ ( )", "self . setup _ rpc ( )", "self . sdnve _ controller _ select ( )", "if self . fake _ controller :", "self . sdnve _ client = sdnve _ fake . FakeClient ( )", "else :", "self . sdnve _ client = sdnve . Client ( )", "def sdnve _ controller _ select ( self ) :", "self . fake _ controller = cfg . CONF . SDNVE . use _ fake _ controller", "def setup _ rpc ( self ) :", "# RPC support", "self . topic = topics . PLUGIN", "self . conn = rpc . create _ connection ( new = True )", "self . notifier = AgentNotifierApi ( topics . AGENT )", "self . callbacks = SdnveRpcCallbacks ( self . notifier )", "self . dispatcher = self . callbacks . create _ rpc _ dispatcher ( )", "self . conn . create _ consumer ( self . topic , self . dispatcher ,", "fanout = False )", "# Consume from all consumers in a thread", "self . conn . consume _ in _ thread ( )", "def _ update _ base _ binding _ dict ( self , tenant _ type ) :", "if tenant _ type = = constants . TENANT _ TYPE _ OVERLAY :", "self . base _ binding _ dict [", "portbindings . VIF _ TYPE ] = portbindings . VIF _ TYPE _ BRIDGE", "if tenant _ type = = constants . TENANT _ TYPE _ OF :", "self . base _ binding _ dict [", "portbindings . VIF _ TYPE ] = portbindings . VIF _ TYPE _ OVS", "def set _ controller ( self , context ) :", "LOG . info ( _ ( `` Set a new controller if needed . `` ) )", "new _ controller = self . sdnve _ client . sdnve _ get _ controller ( )", "if new _ controller :", "self . notifier . info _ update (", "context ,", "{ ' new _ controller ' : new _ controller } )", "LOG . info ( _ ( `` Set the controller to a new controller : % s `` ) ,", "new _ controller )", "def _ process _ request ( self , request , current ) :", "new _ request = dict (", "( k , v ) for k , v in request . items ( )", "if v ! = current . get ( k ) )", "msg = _ ( `` Original SDN - VE HTTP request : % ( orig ) s ; New request : % ( new ) s `` )", "LOG . debug ( msg , { ' orig ' : request , ' new ' : new _ request } )", "return new _ request", "#", "# Network", "#", "@ _ ha", "def create _ network ( self , context , network ) :", "LOG . debug ( _ ( `` Create network in progress : % r `` ) , network )", "session = context . session", "tenant _ id = self . _ get _ tenant _ id _ for _ create ( context , network [ ' network ' ] )", "# Create a new SDN - VE tenant if need be", "sdnve _ tenant = self . sdnve _ client . sdnve _ check _ and _ create _ tenant (", "tenant _ id )", "if sdnve _ tenant is None :", "raise sdnve _ exc . SdnveException (", "msg = _ ( ' Create net failed : no SDN - VE tenant . ' ) )", "with session . begin ( subtransactions = True ) :", "net = super ( SdnvePluginV2 , self ) . create _ network ( context , network )", "self . _ process _ l3 _ create ( context , net , network [ ' network ' ] )", "# Create SDN - VE network", "( res , data ) = self . sdnve _ client . sdnve _ create ( ' network ' , net )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . delete _ network ( context , net [ ' id ' ] )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Create net failed in SDN - VE : % s ' ) % res ) )", "LOG . debug ( _ ( `` Created network : % s `` ) , net [ ' id ' ] )", "return net", "@ _ ha", "def update _ network ( self , context , id , network ) :", "LOG . debug ( _ ( `` Update network in progress : % r `` ) , network )", "session = context . session", "processed _ request = { }", "with session . begin ( subtransactions = True ) :", "original _ network = super ( SdnvePluginV2 , self ) . get _ network (", "context , id )", "processed _ request [ ' network ' ] = self . _ process _ request (", "network [ ' network ' ] , original _ network )", "net = super ( SdnvePluginV2 , self ) . update _ network (", "context , id , network )", "self . _ process _ l3 _ update ( context , net , network [ ' network ' ] )", "if processed _ request [ ' network ' ] :", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' network ' , id , processed _ request [ ' network ' ] )", "if res not in constants . HTTP _ ACCEPTABLE :", "net = super ( SdnvePluginV2 , self ) . update _ network (", "context , id , { ' network ' : original _ network } )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update net failed in SDN - VE : % s ' ) % res ) )", "return net", "@ _ ha", "def delete _ network ( self , context , id ) :", "LOG . debug ( _ ( `` Delete network in progress : % s `` ) , id )", "super ( SdnvePluginV2 , self ) . delete _ network ( context , id )", "( res , data ) = self . sdnve _ client . sdnve _ delete ( ' network ' , id )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error (", "_ ( `` Delete net failed after deleting the network in DB : % s `` ) ,", "res )", "@ _ ha", "def get _ network ( self , context , id , fields = None ) :", "LOG . debug ( _ ( `` Get network in progress : % s `` ) , id )", "return super ( SdnvePluginV2 , self ) . get _ network ( context , id , fields )", "@ _ ha", "def get _ networks ( self , context , filters = None , fields = None , sorts = None ,", "limit = None , marker = None , page _ reverse = False ) :", "LOG . debug ( _ ( `` Get networks in progress `` ) )", "return super ( SdnvePluginV2 , self ) . get _ networks (", "context , filters , fields , sorts , limit , marker , page _ reverse )", "#", "# Port", "#", "@ _ ha", "def create _ port ( self , context , port ) :", "LOG . debug ( _ ( `` Create port in progress : % r `` ) , port )", "session = context . session", "# Set port status as ' ACTIVE ' to avoid needing the agent", "port [ ' port ' ] [ ' status ' ] = q _ const . PORT _ STATUS _ ACTIVE", "port _ data = port [ ' port ' ]", "with session . begin ( subtransactions = True ) :", "port = super ( SdnvePluginV2 , self ) . create _ port ( context , port )", "if ' id ' not in port :", "return port", "# If the tenant _ id is set to ' ' by create _ port , add the id to", "# the request being sent to the controller as the controller", "# requires a tenant id", "tenant _ id = port . get ( ' tenant _ id ' )", "if not tenant _ id :", "LOG . debug ( _ ( `` Create port does not have tenant id info `` ) )", "original _ network = super ( SdnvePluginV2 , self ) . get _ network (", "context , port [ ' network _ id ' ] )", "original _ tenant _ id = original _ network [ ' tenant _ id ' ]", "port [ ' tenant _ id ' ] = original _ tenant _ id", "LOG . debug (", "_ ( `` Create port does not have tenant id info ; ``", "`` obtained is : % s `` ) ,", "port [ ' tenant _ id ' ] )", "os _ tenant _ id = tenant _ id", "id _ na , tenant _ type = self . sdnve _ client . sdnve _ get _ tenant _ byid (", "os _ tenant _ id )", "self . _ update _ base _ binding _ dict ( tenant _ type )", "self . _ process _ portbindings _ create _ and _ update ( context ,", "port _ data , port )", "# NOTE ( mb ) : Remove this block when controller is updated", "# Remove the information that the controller does not accept", "sdnve _ port = port . copy ( )", "sdnve _ port . pop ( ' device _ id ' , None )", "sdnve _ port . pop ( ' device _ owner ' , None )", "( res , data ) = self . sdnve _ client . sdnve _ create ( ' port ' , sdnve _ port )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . delete _ port ( context , port [ ' id ' ] )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Create port failed in SDN - VE : % s ' ) % res ) )", "LOG . debug ( _ ( `` Created port : % s `` ) , port . get ( ' id ' , ' id not found ' ) )", "return port", "@ _ ha", "def update _ port ( self , context , id , port ) :", "LOG . debug ( _ ( `` Update port in progress : % r `` ) , port )", "session = context . session", "processed _ request = { }", "with session . begin ( subtransactions = True ) :", "original _ port = super ( SdnvePluginV2 , self ) . get _ port (", "context , id )", "processed _ request [ ' port ' ] = self . _ process _ request (", "port [ ' port ' ] , original _ port )", "updated _ port = super ( SdnvePluginV2 , self ) . update _ port (", "context , id , port )", "os _ tenant _ id = updated _ port [ ' tenant _ id ' ]", "id _ na , tenant _ type = self . sdnve _ client . sdnve _ get _ tenant _ byid (", "os _ tenant _ id )", "self . _ update _ base _ binding _ dict ( tenant _ type )", "self . _ process _ portbindings _ create _ and _ update ( context ,", "port [ ' port ' ] ,", "updated _ port )", "if processed _ request [ ' port ' ] :", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' port ' , id , processed _ request [ ' port ' ] )", "if res not in constants . HTTP _ ACCEPTABLE :", "updated _ port = super ( SdnvePluginV2 , self ) . update _ port (", "context , id , { ' port ' : original _ port } )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update port failed in SDN - VE : % s ' ) % res ) )", "return updated _ port", "@ _ ha", "def delete _ port ( self , context , id , l3 _ port _ check = True ) :", "LOG . debug ( _ ( `` Delete port in progress : % s `` ) , id )", "# if needed , check to see if this is a port owned by", "# an l3 - router . If so , we should prevent deletion .", "if l3 _ port _ check :", "self . prevent _ l3 _ port _ deletion ( context , id )", "self . disassociate _ floatingips ( context , id )", "super ( SdnvePluginV2 , self ) . delete _ port ( context , id )", "( res , data ) = self . sdnve _ client . sdnve _ delete ( ' port ' , id )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error (", "_ ( `` Delete port operation failed in SDN - VE ``", "`` after deleting the port from DB : % s `` ) , res )", "#", "# Subnet", "#", "@ _ ha", "def create _ subnet ( self , context , subnet ) :", "LOG . debug ( _ ( `` Create subnet in progress : % r `` ) , subnet )", "new _ subnet = super ( SdnvePluginV2 , self ) . create _ subnet ( context , subnet )", "# Note ( mb ) : Use of null string currently required by controller", "sdnve _ subnet = new _ subnet . copy ( )", "if subnet . get ( ' gateway _ ip ' ) is None :", "sdnve _ subnet [ ' gateway _ ip ' ] = ' null '", "( res , data ) = self . sdnve _ client . sdnve _ create ( ' subnet ' , sdnve _ subnet )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . delete _ subnet ( context ,", "new _ subnet [ ' id ' ] )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Create subnet failed in SDN - VE : % s ' ) % res ) )", "LOG . debug ( _ ( `` Subnet created : % s `` ) , new _ subnet [ ' id ' ] )", "return new _ subnet", "@ _ ha", "def update _ subnet ( self , context , id , subnet ) :", "LOG . debug ( _ ( `` Update subnet in progress : % r `` ) , subnet )", "session = context . session", "processed _ request = { }", "with session . begin ( subtransactions = True ) :", "original _ subnet = super ( SdnvePluginV2 , self ) . get _ subnet (", "context , id )", "processed _ request [ ' subnet ' ] = self . _ process _ request (", "subnet [ ' subnet ' ] , original _ subnet )", "updated _ subnet = super ( SdnvePluginV2 , self ) . update _ subnet (", "context , id , subnet )", "if processed _ request [ ' subnet ' ] :", "# Note ( mb ) : Use of string containing null required by controller", "if ' gateway _ ip ' in processed _ request [ ' subnet ' ] :", "if processed _ request [ ' subnet ' ] . get ( ' gateway _ ip ' ) is None :", "processed _ request [ ' subnet ' ] [ ' gateway _ ip ' ] = ' null '", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' subnet ' , id , processed _ request [ ' subnet ' ] )", "if res not in constants . HTTP _ ACCEPTABLE :", "for key in subnet [ ' subnet ' ] . keys ( ) :", "subnet [ ' subnet ' ] [ key ] = original _ subnet [ key ]", "super ( SdnvePluginV2 , self ) . update _ subnet (", "context , id , subnet )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update subnet failed in SDN - VE : % s ' ) % res ) )", "return updated _ subnet", "@ _ ha", "def delete _ subnet ( self , context , id ) :", "LOG . debug ( _ ( `` Delete subnet in progress : % s `` ) , id )", "super ( SdnvePluginV2 , self ) . delete _ subnet ( context , id )", "( res , data ) = self . sdnve _ client . sdnve _ delete ( ' subnet ' , id )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error ( _ ( `` Delete subnet operation failed in SDN - VE after ``", "`` deleting the subnet from DB : % s `` ) , res )", "#", "# Router", "#", "@ _ ha", "def create _ router ( self , context , router ) :", "LOG . debug ( _ ( `` Create router in progress : % r `` ) , router )", "if router [ ' router ' ] [ ' admin _ state _ up ' ] is False :", "LOG . warning ( _ ( ' Ignoring admin _ state _ up = False for router = % r . '", "' Overriding with True ' ) , router )", "router [ ' router ' ] [ ' admin _ state _ up ' ] = True", "tenant _ id = self . _ get _ tenant _ id _ for _ create ( context , router [ ' router ' ] )", "# Create a new Pinnaacles tenant if need be", "sdnve _ tenant = self . sdnve _ client . sdnve _ check _ and _ create _ tenant (", "tenant _ id )", "if sdnve _ tenant is None :", "raise sdnve _ exc . SdnveException (", "msg = _ ( ' Create router failed : no SDN - VE tenant . ' ) )", "new _ router = super ( SdnvePluginV2 , self ) . create _ router ( context , router )", "# Create Sdnve router", "( res , data ) = self . sdnve _ client . sdnve _ create ( ' router ' , new _ router )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . delete _ router ( context , new _ router [ ' id ' ] )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Create router failed in SDN - VE : % s ' ) % res ) )", "LOG . debug ( _ ( `` Router created : % r `` ) , new _ router )", "return new _ router", "@ _ ha", "def update _ router ( self , context , id , router ) :", "LOG . debug ( _ ( `` Update router in progress : id = % ( id ) s ``", "`` router = % ( router ) r `` ) ,", "{ ' id ' : id , ' router ' : router } )", "session = context . session", "processed _ request = { }", "if not router [ ' router ' ] . get ( ' admin _ state _ up ' , True ) :", "raise q _ exc . NotImplementedError ( _ ( ' admin _ state _ up = False '", "' routers are not '", "' supported . ' ) )", "with session . begin ( subtransactions = True ) :", "original _ router = super ( SdnvePluginV2 , self ) . get _ router (", "context , id )", "processed _ request [ ' router ' ] = self . _ process _ request (", "router [ ' router ' ] , original _ router )", "updated _ router = super ( SdnvePluginV2 , self ) . update _ router (", "context , id , router )", "if processed _ request [ ' router ' ] :", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' router ' , id , processed _ request [ ' router ' ] )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . update _ router (", "context , id , { ' router ' : original _ router } )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update router failed in SDN - VE : % s ' ) % res ) )", "return updated _ router", "@ _ ha", "def delete _ router ( self , context , id ) :", "LOG . debug ( _ ( `` Delete router in progress : % s `` ) , id )", "super ( SdnvePluginV2 , self ) . delete _ router ( context , id )", "( res , data ) = self . sdnve _ client . sdnve _ delete ( ' router ' , id )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error (", "_ ( `` Delete router operation failed in SDN - VE after ``", "`` deleting the router in DB : % s `` ) , res )", "@ _ ha", "def add _ router _ interface ( self , context , router _ id , interface _ info ) :", "LOG . debug ( _ ( `` Add router interface in progress : ``", "`` router _ id = % ( router _ id ) s ``", "`` interface _ info = % ( interface _ info ) r `` ) ,", "{ ' router _ id ' : router _ id , ' interface _ info ' : interface _ info } )", "new _ interface = super ( SdnvePluginV2 , self ) . add _ router _ interface (", "context , router _ id , interface _ info )", "LOG . debug (", "_ ( `` SdnvePluginV2 . add _ router _ interface called . Port info : % s `` ) ,", "new _ interface )", "request _ info = interface _ info . copy ( )", "request _ info [ ' port _ id ' ] = new _ interface [ ' port _ id ' ]", "# Add the subnet _ id to the request sent to the controller", "if ' subnet _ id ' not in interface _ info :", "request _ info [ ' subnet _ id ' ] = new _ interface [ ' subnet _ id ' ]", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' router ' , router _ id + ' / add _ router _ interface ' , request _ info )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . remove _ router _ interface (", "context , router _ id , interface _ info )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update router - add - interface failed in SDN - VE : % s ' ) %", "res ) )", "LOG . debug ( _ ( `` Added router interface : % r `` ) , new _ interface )", "return new _ interface", "def _ add _ router _ interface _ only ( self , context , router _ id , interface _ info ) :", "LOG . debug ( _ ( `` Add router interface only called : ``", "`` router _ id = % ( router _ id ) s ``", "`` interface _ info = % ( interface _ info ) r `` ) ,", "{ ' router _ id ' : router _ id , ' interface _ info ' : interface _ info } )", "port _ id = interface _ info . get ( ' port _ id ' )", "if port _ id :", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' router ' , router _ id + ' / add _ router _ interface ' , interface _ info )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error ( _ ( `` SdnvePluginV2 . _ add _ router _ interface _ only : ``", "`` failed to add the interface in the roll back . ``", "`` of a remove _ router _ interface operation `` ) )", "@ _ ha", "def remove _ router _ interface ( self , context , router _ id , interface _ info ) :", "LOG . debug ( _ ( `` Remove router interface in progress : ``", "`` router _ id = % ( router _ id ) s ``", "`` interface _ info = % ( interface _ info ) r `` ) ,", "{ ' router _ id ' : router _ id , ' interface _ info ' : interface _ info } )", "subnet _ id = interface _ info . get ( ' subnet _ id ' )", "if not subnet _ id :", "portid = interface _ info . get ( ' port _ id ' )", "if not portid :", "raise sdnve _ exc . BadInputException ( msg = _ ( ' No port ID ' ) )", "myport = super ( SdnvePluginV2 , self ) . get _ port ( context , portid )", "LOG . debug ( _ ( `` SdnvePluginV2 . remove _ router _ interface port : % s `` ) ,", "myport )", "myfixed _ ips = myport . get ( ' fixed _ ips ' )", "if not myfixed _ ips :", "raise sdnve _ exc . BadInputException ( msg = _ ( ' No fixed IP ' ) )", "subnet _ id = myfixed _ ips [ 0 ] . get ( ' subnet _ id ' )", "if subnet _ id :", "interface _ info [ ' subnet _ id ' ] = subnet _ id", "LOG . debug (", "_ ( `` SdnvePluginV2 . remove _ router _ interface subnet _ id : % s `` ) ,", "subnet _ id )", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' router ' , router _ id + ' / remove _ router _ interface ' , interface _ info )", "if res not in constants . HTTP _ ACCEPTABLE :", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update router - remove - interface failed SDN - VE : % s ' ) %", "res ) )", "session = context . session", "with session . begin ( subtransactions = True ) :", "try :", "info = super ( SdnvePluginV2 , self ) . remove _ router _ interface (", "context , router _ id , interface _ info )", "except Exception :", "with excutils . save _ and _ reraise _ exception ( ) :", "self . _ add _ router _ interface _ only ( context ,", "router _ id , interface _ info )", "return info", "#", "# Floating Ip", "#", "@ _ ha", "def create _ floatingip ( self , context , floatingip ) :", "LOG . debug ( _ ( `` Create floatingip in progress : % r `` ) ,", "floatingip )", "new _ floatingip = super ( SdnvePluginV2 , self ) . create _ floatingip (", "context , floatingip )", "( res , data ) = self . sdnve _ client . sdnve _ create (", "' floatingip ' , { ' floatingip ' : new _ floatingip } )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . delete _ floatingip (", "context , new _ floatingip [ ' id ' ] )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Creating floating ip operation failed '", "' in SDN - VE controller : % s ' ) % res ) )", "LOG . debug ( _ ( `` Created floatingip : % r `` ) , new _ floatingip )", "return new _ floatingip", "@ _ ha", "def update _ floatingip ( self , context , id , floatingip ) :", "LOG . debug ( _ ( `` Update floatingip in progress : % r `` ) , floatingip )", "session = context . session", "processed _ request = { }", "with session . begin ( subtransactions = True ) :", "original _ floatingip = super (", "SdnvePluginV2 , self ) . get _ floatingip ( context , id )", "processed _ request [ ' floatingip ' ] = self . _ process _ request (", "floatingip [ ' floatingip ' ] , original _ floatingip )", "updated _ floatingip = super (", "SdnvePluginV2 , self ) . update _ floatingip ( context , id , floatingip )", "if processed _ request [ ' floatingip ' ] :", "( res , data ) = self . sdnve _ client . sdnve _ update (", "' floatingip ' , id ,", "{ ' floatingip ' : processed _ request [ ' floatingip ' ] } )", "if res not in constants . HTTP _ ACCEPTABLE :", "super ( SdnvePluginV2 , self ) . update _ floatingip (", "context , id , { ' floatingip ' : original _ floatingip } )", "raise sdnve _ exc . SdnveException (", "msg = ( _ ( ' Update floating ip failed in SDN - VE : % s ' ) % res ) )", "return updated _ floatingip", "@ _ ha", "def delete _ floatingip ( self , context , id ) :", "LOG . debug ( _ ( `` Delete floatingip in progress : % s `` ) , id )", "super ( SdnvePluginV2 , self ) . delete _ floatingip ( context , id )", "( res , data ) = self . sdnve _ client . sdnve _ delete ( ' floatingip ' , id )", "if res not in constants . HTTP _ ACCEPTABLE :", "LOG . error ( _ ( `` Delete floatingip failed in SDN - VE : % s `` ) , res )", ],"removed_code":[]},{"added_code":[],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp", "import contextlib", "import mock", "from oslo . config import cfg", "from neutron . agent . linux import ip _ lib", "from neutron . plugins . ibm . agent import sdnve _ neutron _ agent", "from neutron . tests import base", "NOTIFIER = ( ' neutron . plugins . ibm . '", "' sdnve _ neutron _ plugin . AgentNotifierApi ' )", "class CreateAgentConfigMap ( base . BaseTestCase ) :", "def test _ create _ agent _ config _ map _ succeeds ( self ) :", "self . assertTrue ( sdnve _ neutron _ agent . create _ agent _ config _ map ( cfg . CONF ) )", "def test _ create _ agent _ config _ using _ controller _ ips ( self ) :", "self . addCleanup ( cfg . CONF . reset )", "cfg . CONF . set _ override ( ' controller _ ips ' ,", "[ ' 10 . 10 . 10 . 1 ' , ' 10 . 10 . 10 . 2 ' ] , group = ' SDNVE ' )", "cfgmap = sdnve _ neutron _ agent . create _ agent _ config _ map ( cfg . CONF )", "self . assertEqual ( cfgmap [ ' controller _ ip ' ] , ' 10 . 10 . 10 . 1 ' )", "def test _ create _ agent _ config _ using _ interface _ mappings ( self ) :", "self . addCleanup ( cfg . CONF . reset )", "cfg . CONF . set _ override ( ' interface _ mappings ' ,", "[ ' interface1 : eth1 ' , ' interface2 : eth2 ' ] ,", "group = ' SDNVE ' )", "cfgmap = sdnve _ neutron _ agent . create _ agent _ config _ map ( cfg . CONF )", "self . assertEqual ( cfgmap [ ' interface _ mappings ' ] ,", "{ ' interface1 ' : ' eth1 ' , ' interface2 ' : ' eth2 ' } )", "class TestSdnveNeutronAgent ( base . BaseTestCase ) :", "def setUp ( self ) :", "super ( TestSdnveNeutronAgent , self ) . setUp ( )", "self . addCleanup ( cfg . CONF . reset )", "notifier _ p = mock . patch ( NOTIFIER )", "notifier _ cls = notifier _ p . start ( )", "self . notifier = mock . Mock ( )", "notifier _ cls . return _ value = self . notifier", "# Avoid rpc initialization for unit tests", "cfg . CONF . set _ override ( ' rpc _ backend ' ,", "' neutron . openstack . common . rpc . impl _ fake ' )", "cfg . CONF . set _ override ( ' integration _ bridge ' ,", "' br _ int ' , group = ' SDNVE ' )", "kwargs = sdnve _ neutron _ agent . create _ agent _ config _ map ( cfg . CONF )", "class MockFixedIntervalLoopingCall ( object ) :", "def _ _ init _ _ ( self , f ) :", "self . f = f", "def start ( self , interval = 0 ) :", "self . f ( )", "with contextlib . nested (", "mock . patch ( ' neutron . plugins . ibm . agent . sdnve _ neutron _ agent . '", "' SdnveNeutronAgent . setup _ integration _ br ' ,", "return _ value = mock . Mock ( ) ) ,", "mock . patch ( ' neutron . openstack . common . loopingcall . '", "' FixedIntervalLoopingCall ' ,", "new = MockFixedIntervalLoopingCall ) ) :", "self . agent = sdnve _ neutron _ agent . SdnveNeutronAgent ( * * kwargs )", "def test _ setup _ physical _ interfaces ( self ) :", "with mock . patch . object ( self . agent . int _ br ,", "' add _ port ' ) as add _ port _ func :", "with mock . patch . object ( ip _ lib ,", "' device _ exists ' ,", "return _ valxue = True ) :", "self . agent . setup _ physical _ interfaces ( { `` interface1 `` : `` eth1 `` } )", "add _ port _ func . assert _ called _ once _ with ( ' eth1 ' )", "def test _ setup _ physical _ interfaces _ none ( self ) :", "with mock . patch . object ( self . agent . int _ br ,", "' add _ port ' ) as add _ port _ func :", "with mock . patch . object ( ip _ lib ,", "' device _ exists ' ,", "return _ valxue = True ) :", "self . agent . setup _ physical _ interfaces ( { } )", "self . assertFalse ( add _ port _ func . called )", "def test _ get _ info _ set _ controller ( self ) :", "with mock . patch . object ( self . agent . int _ br ,", "' run _ vsctl ' ) as run _ vsctl _ func :", "kwargs = { }", "kwargs [ ' info ' ] = { ' new _ controller ' : ' 10 . 10 . 10 . 1 ' }", "self . agent . info _ update ( ' dummy ' , * * kwargs )", "run _ vsctl _ func . assert _ called _ one _ with ( [ ' set - controller ' ,", "' br _ int ' ,", "' tcp : 10 . 10 . 10 . 1 ' ] )", "def test _ get _ info ( self ) :", "with mock . patch . object ( self . agent . int _ br ,", "' run _ vsctl ' ) as run _ vsctl _ func :", "kwargs = { }", "self . agent . info _ update ( ' dummy ' , * * kwargs )", "self . assertFalse ( run _ vsctl _ func . called )", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp", "import mock", "from oslo . config import cfg", "from neutron . openstack . common import uuidutils", "from neutron . plugins . ibm . common import constants", "from neutron . plugins . ibm import sdnve _ api", "from neutron . tests import base", "RESOURCE _ PATH = {", "' network ' : `` ln / networks / `` ,", "}", "RESOURCE = ' network '", "HTTP _ OK = 200", "TENANT _ ID = uuidutils . generate _ uuid ( )", "class TestSdnveApi ( base . BaseTestCase ) :", "def setUp ( self ) :", "super ( TestSdnveApi , self ) . setUp ( )", "self . addCleanup ( cfg . CONF . reset )", "class MockKeystoneClient ( object ) :", "def _ _ init _ _ ( self , * * kwargs ) :", "pass", "def get _ tenant _ name ( self , id ) :", "return ' test tenant name '", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' KeystoneClient ' ,", "new = MockKeystoneClient ) :", "self . api = sdnve _ api . Client ( )", "def mock _ do _ request ( self , method , url , body = None , headers = None ,", "params = None , connection _ type = None ) :", "return ( HTTP _ OK , url )", "def mock _ do _ request _ tenant ( self , method , url , body = None , headers = None ,", "params = None , connection _ type = None ) :", "return ( HTTP _ OK , { ' id ' : TENANT _ ID ,", "' network _ type ' : constants . TENANT _ TYPE _ OF } )", "def mock _ do _ request _ no _ tenant ( self , method , url , body = None , headers = None ,", "params = None , connection _ type = None ) :", "return ( None , None )", "def mock _ process _ request ( self , body ) :", "return body", "def test _ sdnve _ api _ list ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request ) :", "result = self . api . sdnve _ list ( RESOURCE )", "self . assertEqual ( result , ( HTTP _ OK , RESOURCE _ PATH [ RESOURCE ] ) )", "def test _ sdnve _ api _ show ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request ) :", "result = self . api . sdnve _ show ( RESOURCE , TENANT _ ID )", "self . assertEqual ( result ,", "( HTTP _ OK , RESOURCE _ PATH [ RESOURCE ] + TENANT _ ID ) )", "def test _ sdnve _ api _ create ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . process _ request ' ,", "new = self . mock _ process _ request ) :", "result = self . api . sdnve _ create ( RESOURCE , ' ' )", "self . assertEqual ( result , ( HTTP _ OK , RESOURCE _ PATH [ RESOURCE ] ) )", "def test _ sdnve _ api _ update ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . process _ request ' ,", "new = self . mock _ process _ request ) :", "result = self . api . sdnve _ update ( RESOURCE , TENANT _ ID , ' ' )", "self . assertEqual ( result ,", "( HTTP _ OK ,", "RESOURCE _ PATH [ RESOURCE ] + TENANT _ ID ) )", "def test _ sdnve _ api _ delete ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request ) :", "result = self . api . sdnve _ delete ( RESOURCE , TENANT _ ID )", "self . assertEqual ( result ,", "( HTTP _ OK , RESOURCE _ PATH [ RESOURCE ] + TENANT _ ID ) )", "def test _ sdnve _ get _ tenant _ by _ id ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request _ tenant ) :", "id = TENANT _ ID", "result = self . api . sdnve _ get _ tenant _ byid ( id )", "self . assertEqual ( result ,", "( TENANT _ ID , constants . TENANT _ TYPE _ OF ) )", "def test _ sdnve _ check _ and _ create _ tenant ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request _ tenant ) :", "id = TENANT _ ID", "result = self . api . sdnve _ check _ and _ create _ tenant ( id )", "self . assertEqual ( result , TENANT _ ID )", "def test _ sdnve _ check _ and _ create _ tenant _ fail ( self ) :", "with mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client . do _ request ' ,", "new = self . mock _ do _ request _ no _ tenant ) :", "id = TENANT _ ID", "result = self . api . sdnve _ check _ and _ create _ tenant (", "id , constants . TENANT _ TYPE _ OF )", "self . assertIsNone ( result )", ],"removed_code":[]},{"added_code":["Copyright 2014 IBM Corp .", "", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "", "@ author : Mohammad Banikazemi , IBM Corp", "import contextlib", "import mock", "from neutron . extensions import portbindings", "from neutron . tests . unit import _ test _ extension _ portbindings as test _ bindings", "from neutron . tests . unit import test _ db _ plugin as test _ plugin", "from neutron . tests . unit import test _ l3 _ plugin as test _ l3 _ plugin", "from neutron . plugins . ibm . common import constants", "_ plugin _ name = ( ' neutron . plugins . ibm . '", "' sdnve _ neutron _ plugin . SdnvePluginV2 ' )", "HTTP _ OK = 200", "class MockClient ( object ) :", "def sdnve _ list ( self , resource , * * params ) :", "return ( HTTP _ OK , ' body ' )", "def sdnve _ show ( self , resource , specific , * * params ) :", "return ( HTTP _ OK , ' body ' )", "def sdnve _ create ( self , resource , body ) :", "return ( HTTP _ OK , ' body ' )", "def sdnve _ update ( self , resource , specific , body = None ) :", "return ( HTTP _ OK , ' body ' )", "def sdnve _ delete ( self , resource , specific ) :", "return ( HTTP _ OK , ' body ' )", "def sdnve _ get _ tenant _ byid ( self , os _ tenant _ id ) :", "return ( os _ tenant _ id , constants . TENANT _ TYPE _ OF )", "def sdnve _ check _ and _ create _ tenant (", "self , os _ tenant _ id , network _ type = None ) :", "return os _ tenant _ id", "def sdnve _ get _ controller ( self ) :", "return", "class MockKeystoneClient ( object ) :", "def _ _ init _ _ ( self , * * kwargs ) :", "pass", "def get _ tenant _ type ( self , id ) :", "return constants . TENANT _ TYPE _ OF", "def get _ tenant _ name ( self , id ) :", "return `` tenant name ``", "class IBMPluginV2TestCase ( test _ plugin . NeutronDbPluginV2TestCase ) :", "def setUp ( self ) :", "with contextlib . nested (", "mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' KeystoneClient ' ,", "new = MockKeystoneClient ) ,", "mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client ' ,", "new = MockClient ) ) :", "super ( IBMPluginV2TestCase , self ) . setUp ( plugin = _ plugin _ name )", "class TestIBMBasicGet ( test _ plugin . TestBasicGet ,", "IBMPluginV2TestCase ) :", "pass", "class TestIBMV2HTTPResponse ( test _ plugin . TestV2HTTPResponse ,", "IBMPluginV2TestCase ) :", "pass", "class TestIBMNetworksV2 ( test _ plugin . TestNetworksV2 ,", "IBMPluginV2TestCase ) :", "pass", "class TestIBMPortsV2 ( test _ plugin . TestPortsV2 ,", "IBMPluginV2TestCase ) :", "pass", "class TestIBMSubnetsV2 ( test _ plugin . TestSubnetsV2 ,", "IBMPluginV2TestCase ) :", "pass", "class TestIBMPortBinding ( IBMPluginV2TestCase ,", "test _ bindings . PortBindingsTestCase ) :", "VIF _ TYPE = portbindings . VIF _ TYPE _ OVS", "class IBMPluginRouterTestCase ( test _ l3 _ plugin . L3NatDBIntTestCase ) :", "def setUp ( self ) :", "with contextlib . nested (", "mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' KeystoneClient ' ,", "new = MockKeystoneClient ) ,", "mock . patch ( ' neutron . plugins . ibm . sdnve _ api . '", "' Client ' ,", "new = MockClient ) ) :", "super ( IBMPluginRouterTestCase , self ) . setUp ( plugin = _ plugin _ name )", ],"removed_code":[]},{"added_code":["etc / neutron / plugins / ibm = etc / neutron / plugins / ibm / sdnve _ neutron _ plugin . ini", "neutron - ibm - agent = neutron . plugins . ibm . agent . sdnve _ neutron _ agent : main", "quantum - ibm - agent = neutron . plugins . ibm . agent . sdnve _ neutron _ agent : main", "ibm = neutron . plugins . ibm . sdnve _ neutron _ plugin : SdnvePluginV2", ],"removed_code":[]},],[{"added_code":["instance = instance _ obj . Instance . _ from _ db _ object (", "context , instance _ obj . Instance ( ) , instance )", "connect _ info = self . driver . get _ vnc _ console ( context , instance )", "instance = instance _ obj . Instance . _ from _ db _ object (", "ctxt , instance _ obj . Instance ( ) , instance )", "console _ info = self . driver . get _ vnc _ console ( ctxt , instance )", ],"removed_code":["connect _ info = self . driver . get _ vnc _ console ( instance )", "instance = instance _ obj . Instance . _ from _ db _ object (", "ctxt , instance _ obj . Instance ( ) , instance )", "console _ info = self . driver . get _ vnc _ console ( instance )", ]},{"added_code":["instance = self . _ create _ fake _ instance _ obj ( )", "self . compute . run _ instance ( self . context ,", "jsonutils . to _ primitive ( instance ) , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context , instance , [ ] , [ ] )", "instance = self . _ create _ fake _ instance _ obj ( )", "self . compute . run _ instance ( self . context ,", "jsonutils . to _ primitive ( instance ) , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context , instance , [ ] , [ ] )", "instance = self . _ create _ fake _ instance _ obj ( )", "self . compute . run _ instance ( self . context ,", "jsonutils . to _ primitive ( instance ) , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context , instance , [ ] , [ ] )", "instance = self . _ create _ fake _ instance _ obj ( )", "self . compute . run _ instance ( self . context ,", "jsonutils . to _ primitive ( instance ) , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context , instance , [ ] , [ ] )", "instance = self . _ create _ fake _ instance _ obj (", ],"removed_code":["instance = jsonutils . to _ primitive ( self . _ create _ fake _ instance ( ) )", "self . compute . run _ instance ( self . context , instance , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context ,", "self . _ objectify ( instance ) , [ ] , [ ] )", "instance = jsonutils . to _ primitive ( self . _ create _ fake _ instance ( ) )", "self . compute . run _ instance ( self . context , instance , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context ,", "self . _ objectify ( instance ) , [ ] , [ ] )", "instance = jsonutils . to _ primitive ( self . _ create _ fake _ instance ( ) )", "self . compute . run _ instance ( self . context , instance , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context ,", "self . _ objectify ( instance ) , [ ] , [ ] )", "instance = jsonutils . to _ primitive ( self . _ create _ fake _ instance ( ) )", "self . compute . run _ instance ( self . context , instance , { } , { } , [ ] , None ,", "None , True , None , False )", "self . compute . terminate _ instance ( self . context ,", "self . _ objectify ( instance ) , [ ] , [ ] )", "instance = self . _ create _ fake _ instance (", "instance = jsonutils . to _ primitive ( instance )", ]},{"added_code":["from nova . openstack . common import jsonutils", "def _ get _ running _ instance ( self , obj = False ) :", "instance _ ref = utils . get _ test _ instance ( obj = obj )", "self . connection . spawn ( self . ctxt , jsonutils . to _ primitive ( instance _ ref ) ,", "image _ info , [ ] , ' herp ' , network _ info = network _ info )", ],"removed_code":["def _ get _ running _ instance ( self ) :", "instance _ ref = utils . get _ test _ instance ( )", "self . connection . spawn ( self . ctxt , instance _ ref , image _ info ,", "[ ] , ' herp ' , network _ info = network _ info )", ]},{"added_code":["instance = self . create _ instance _ obj ( self . context )", "if instance _ name = = instance [ ' name ' ] :", "vnc _ dict = conn . get _ vnc _ console ( self . context , instance )", "instance = self . create _ instance _ obj ( self . context )", "if instance _ name = = instance [ ' name ' ] :", "conn . get _ vnc _ console , self . context , instance )", ],"removed_code":["instance _ ref = db . instance _ create ( self . context , self . test _ instance )", "if instance _ name = = instance _ ref [ ' name ' ] :", "vnc _ dict = conn . get _ vnc _ console ( instance _ ref )", "instance _ ref = db . instance _ create ( self . context , self . test _ instance )", "if instance _ name = = instance _ ref [ ' name ' ] :", "conn . get _ vnc _ console , instance _ ref )", ]},{"added_code":["def _ get _ running _ instance ( self , obj = False ) :", "instance _ ref = test _ utils . get _ test _ instance ( obj = obj )", "instance , network _ info = self . _ get _ running _ instance ( obj = True )", "vnc _ console = self . connection . get _ vnc _ console ( self . ctxt , instance )", ],"removed_code":["def _ get _ running _ instance ( self ) :", "instance _ ref = test _ utils . get _ test _ instance ( )", "instance _ ref , network _ info = self . _ get _ running _ instance ( )", "vnc _ console = self . connection . get _ vnc _ console ( instance _ ref )", ]},{"added_code":["self . context ,", "vnc _ dict = self . conn . get _ vnc _ console ( self . context , self . instance )", ],"removed_code":["vnc _ dict = self . conn . get _ vnc _ console ( self . instance )", ]},{"added_code":["from nova . objects import instance as instance _ obj", "instance = self . _ create _ instance ( obj = True )", "console = conn . get _ vnc _ console ( self . context , instance )", "instance = self . _ create _ instance ( obj = True )", "console = conn . get _ vnc _ console ( self . context , instance )", "instance = self . _ create _ instance ( obj = True , spawn = False )", "instance . vm _ state = ' building '", "conn . get _ vnc _ console , self . context , instance )", "instance = self . _ create _ instance ( obj = True , spawn = False )", "instance . vm _ state = ' rescued '", "conn . get _ vnc _ console , self . context , instance )", "def _ create _ instance ( self , instance _ id = 1 , spawn = True , obj = False , * * attrs ) :", "instance _ values . update ( attrs )", "if obj :", "instance = instance _ obj . Instance . _ from _ db _ object (", "self . context , instance _ obj . Instance ( ) , instance ,", "expected _ attrs = instance _ obj . INSTANCE _ DEFAULT _ FIELDS )", ],"removed_code":["instance = self . _ create _ instance ( )", "console = conn . get _ vnc _ console ( instance )", "instance = self . _ create _ instance ( )", "console = conn . get _ vnc _ console ( instance )", "instance = { }", "# set instance name and state", "instance [ ' name ' ] = ' fake - instance '", "instance [ ' uuid ' ] = ' 00000000 - 0000 - 0000 - 0000 - 000000000000 '", "instance [ ' vm _ state ' ] = ' building '", "conn . get _ vnc _ console , instance )", "instance = { }", "instance [ ' name ' ] = ' fake - rescue '", "instance [ ' uuid ' ] = ' 00000000 - 0000 - 0000 - 0000 - 000000000001 '", "instance [ ' vm _ state ' ] = ' rescued '", "conn . get _ vnc _ console , instance )", "def _ create _ instance ( self , instance _ id = 1 , spawn = True ) :", ]},{"added_code":["def get _ vnc _ console ( self , context , instance ) :", "`` `` `` Get connection info for a vnc console .", ": param context : security context", ": param instance : nova . objects . instance . Instance", "`` `` ``", ],"removed_code":["def get _ vnc _ console ( self , instance ) :", "# TODO ( Vek ) : Need to pass context in for access to auth _ token", ]},{"added_code":["def get _ vnc _ console ( self , context , instance ) :", ],"removed_code":["def get _ vnc _ console ( self , instance ) :", ]},{"added_code":["def get _ vnc _ console ( self , context , instance ) :", "port = get _ vnc _ port _ for _ instance ( instance . name )", ],"removed_code":["def get _ vnc _ console ( self , instance ) :", "port = get _ vnc _ port _ for _ instance ( instance [ ' name ' ] )", ]},{"added_code":["def get _ vnc _ console ( self , context , instance ) :", "def get _ vnc _ console ( self , context , instance ) :", ],"removed_code":["def get _ vnc _ console ( self , instance ) :", "def get _ vnc _ console ( self , instance ) :", ]},{"added_code":["def get _ vnc _ console ( self , context , instance ) :", ],"removed_code":["def get _ vnc _ console ( self , instance ) :", ]},{"added_code":["if instance . vm _ state = = vm _ states . RESCUED :", "name = ' % s - rescue ' % instance . name", "raise exception . InstanceNotReady ( instance _ id = instance . uuid )", "vm _ ref = vm _ utils . lookup ( self . _ session , instance . name )", "raise exception . InstanceNotFound ( instance _ id = instance . uuid )", ],"removed_code":["if instance [ ' vm _ state ' ] = = vm _ states . RESCUED :", "name = ' % s - rescue ' % instance [ ' name ' ]", "raise exception . InstanceNotReady ( instance _ id = instance [ ' uuid ' ] )", "vm _ ref = vm _ utils . lookup ( self . _ session , instance [ ' name ' ] )", "raise exception . InstanceNotFound ( instance _ id = instance [ ' uuid ' ] )", ]},],[{"added_code":[],"removed_code":[]},{"added_code":["Copyright 2011 OpenStack LLC .", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Module dedicated functions / classes dealing with rate limiting requests .", "`` `` ``", "import collections", "import copy", "import httplib", "import math", "import re", "import time", "import webob . dec", "import webob . exc", "from cinder . api . openstack import wsgi", "from cinder . api . views import limits as limits _ views", "from cinder . api import xmlutil", "from cinder . openstack . common import importutils", "from cinder . openstack . common import jsonutils", "from cinder import quota", "from cinder import wsgi as base _ wsgi", "QUOTAS = quota . QUOTAS", "Convenience constants for the limits dictionary passed to Limiter ( ) .", "PER _ SECOND = 1", "PER _ MINUTE = 60", "PER _ HOUR = 60 * 60", "PER _ DAY = 60 * 60 * 24", "limits _ nsmap = { None : xmlutil . XMLNS _ COMMON _ V10 , ' atom ' : xmlutil . XMLNS _ ATOM }", "class LimitsTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' limits ' , selector = ' limits ' )", "rates = xmlutil . SubTemplateElement ( root , ' rates ' )", "rate = xmlutil . SubTemplateElement ( rates , ' rate ' , selector = ' rate ' )", "rate . set ( ' uri ' , ' uri ' )", "rate . set ( ' regex ' , ' regex ' )", "limit = xmlutil . SubTemplateElement ( rate , ' limit ' , selector = ' limit ' )", "limit . set ( ' value ' , ' value ' )", "limit . set ( ' verb ' , ' verb ' )", "limit . set ( ' remaining ' , ' remaining ' )", "limit . set ( ' unit ' , ' unit ' )", "limit . set ( ' next - available ' , ' next - available ' )", "absolute = xmlutil . SubTemplateElement ( root , ' absolute ' ,", "selector = ' absolute ' )", "limit = xmlutil . SubTemplateElement ( absolute , ' limit ' ,", "selector = xmlutil . get _ items )", "limit . set ( ' name ' , 0 )", "limit . set ( ' value ' , 1 )", "return xmlutil . MasterTemplate ( root , 1 , nsmap = limits _ nsmap )", "class LimitsController ( object ) :", "`` `` ``", "Controller for accessing limits in the OpenStack API .", "`` `` ``", "@ wsgi . serializers ( xml = LimitsTemplate )", "def index ( self , req ) :", "`` `` ``", "Return all global and rate limit information .", "`` `` ``", "context = req . environ [ ' cinder . context ' ]", "quotas = QUOTAS . get _ project _ quotas ( context , context . project _ id ,", "usages = False )", "abs _ limits = dict ( ( k , v [ ' limit ' ] ) for k , v in quotas . items ( ) )", "rate _ limits = req . environ . get ( `` cinder . limits `` , [ ] )", "builder = self . _ get _ view _ builder ( req )", "return builder . build ( rate _ limits , abs _ limits )", "def _ get _ view _ builder ( self , req ) :", "return limits _ views . ViewBuilder ( )", "def create _ resource ( ) :", "return wsgi . Resource ( LimitsController ( ) )", "class Limit ( object ) :", "`` `` ``", "Stores information about a limit for HTTP requests .", "`` `` ``", "UNITS = {", "1 : `` SECOND `` ,", "60 : `` MINUTE `` ,", "60 * 60 : `` HOUR `` ,", "60 * 60 * 24 : `` DAY `` ,", "}", "UNIT _ MAP = dict ( [ ( v , k ) for k , v in UNITS . items ( ) ] )", "def _ _ init _ _ ( self , verb , uri , regex , value , unit ) :", "`` `` ``", "Initialize a new ` Limit ` .", "@ param verb : HTTP verb ( POST , PUT , etc . )", "@ param uri : Human - readable URI", "@ param regex : Regular expression format for this limit", "@ param value : Integer number of requests which can be made", "@ param unit : Unit of measure for the value parameter", "`` `` ``", "self . verb = verb", "self . uri = uri", "self . regex = regex", "self . value = int ( value )", "self . unit = unit", "self . unit _ string = self . display _ unit ( ) . lower ( )", "self . remaining = int ( value )", "if value < = 0 :", "raise ValueError ( `` Limit value must be > 0 `` )", "self . last _ request = None", "self . next _ request = None", "self . water _ level = 0", "self . capacity = self . unit", "self . request _ value = float ( self . capacity ) / float ( self . value )", "msg = _ ( `` Only % ( value ) s % ( verb ) s request ( s ) can be ``", "`` made to % ( uri ) s every % ( unit _ string ) s . `` )", "self . error _ message = msg % self . _ _ dict _ _", "def _ _ call _ _ ( self , verb , url ) :", "`` `` ``", "Represents a call to this limit from a relevant request .", "@ param verb : string http verb ( POST , GET , etc . )", "@ param url : string URL", "`` `` ``", "if self . verb ! = verb or not re . match ( self . regex , url ) :", "return", "now = self . _ get _ time ( )", "if self . last _ request is None :", "self . last _ request = now", "leak _ value = now - self . last _ request", "self . water _ level - = leak _ value", "self . water _ level = max ( self . water _ level , 0 )", "self . water _ level + = self . request _ value", "difference = self . water _ level - self . capacity", "self . last _ request = now", "if difference > 0 :", "self . water _ level - = self . request _ value", "self . next _ request = now + difference", "return difference", "cap = self . capacity", "water = self . water _ level", "val = self . value", "self . remaining = math . floor ( ( ( cap - water ) / cap ) * val )", "self . next _ request = now", "def _ get _ time ( self ) :", "`` `` `` Retrieve the current time . Broken out for testability . `` `` ``", "return time . time ( )", "def display _ unit ( self ) :", "`` `` `` Display the string name of the unit . `` `` ``", "return self . UNITS . get ( self . unit , `` UNKNOWN `` )", "def display ( self ) :", "`` `` `` Return a useful representation of this class . `` `` ``", "return {", "`` verb `` : self . verb ,", "`` URI `` : self . uri ,", "`` regex `` : self . regex ,", "`` value `` : self . value ,", "`` remaining `` : int ( self . remaining ) ,", "`` unit `` : self . display _ unit ( ) ,", "`` resetTime `` : int ( self . next _ request or self . _ get _ time ( ) ) ,", "}", "`` Limit `` format is a dictionary with the HTTP verb , human - readable URI ,", "a regular - expression to match , value and unit of measure ( PER _ DAY , etc . )", "DEFAULT _ LIMITS = [", "Limit ( `` POST `` , `` * `` , `` . * `` , 10 , PER _ MINUTE ) ,", "Limit ( `` POST `` , `` * / servers `` , `` ^ / servers `` , 50 , PER _ DAY ) ,", "Limit ( `` PUT `` , `` * `` , `` . * `` , 10 , PER _ MINUTE ) ,", "Limit ( `` GET `` , `` * changes - since * `` , `` . * changes - since . * `` , 3 , PER _ MINUTE ) ,", "Limit ( `` DELETE `` , `` * `` , `` . * `` , 100 , PER _ MINUTE ) ,", "]", "class RateLimitingMiddleware ( base _ wsgi . Middleware ) :", "`` `` ``", "Rate - limits requests passing through this middleware . All limit information", "is stored in memory for this implementation .", "`` `` ``", "def _ _ init _ _ ( self , application , limits = None , limiter = None , * * kwargs ) :", "`` `` ``", "Initialize new ` RateLimitingMiddleware ` , which wraps the given WSGI", "application and sets up the given limits .", "@ param application : WSGI application to wrap", "@ param limits : String describing limits", "@ param limiter : String identifying class for representing limits", "Other parameters are passed to the constructor for the limiter .", "`` `` ``", "base _ wsgi . Middleware . _ _ init _ _ ( self , application )", "# Select the limiter class", "if limiter is None :", "limiter = Limiter", "else :", "limiter = importutils . import _ class ( limiter )", "# Parse the limits , if any are provided", "if limits is not None :", "limits = limiter . parse _ limits ( limits )", "self . _ limiter = limiter ( limits or DEFAULT _ LIMITS , * * kwargs )", "@ webob . dec . wsgify ( RequestClass = wsgi . Request )", "def _ _ call _ _ ( self , req ) :", "`` `` ``", "Represents a single call through this middleware . We should record the", "request if we have a limit relevant to it . If no limit is relevant to", "the request , ignore it .", "If the request should be rate limited , return a fault telling the user", "they are over the limit and need to retry later .", "`` `` ``", "verb = req . method", "url = req . url", "context = req . environ . get ( `` cinder . context `` )", "if context :", "username = context . user _ id", "else :", "username = None", "delay , error = self . _ limiter . check _ for _ delay ( verb , url , username )", "if delay :", "msg = _ ( `` This request was rate - limited . `` )", "retry = time . time ( ) + delay", "return wsgi . OverLimitFault ( msg , error , retry )", "req . environ [ `` cinder . limits `` ] = self . _ limiter . get _ limits ( username )", "return self . application", "class Limiter ( object ) :", "`` `` ``", "Rate - limit checking class which handles limits in memory .", "`` `` ``", "def _ _ init _ _ ( self , limits , * * kwargs ) :", "`` `` ``", "Initialize the new ` Limiter ` .", "@ param limits : List of ` Limit ` objects", "`` `` ``", "self . limits = copy . deepcopy ( limits )", "self . levels = collections . defaultdict ( lambda : copy . deepcopy ( limits ) )", "# Pick up any per - user limit information", "for key , value in kwargs . items ( ) :", "if key . startswith ( ' user : ' ) :", "username = key [ 5 : ]", "self . levels [ username ] = self . parse _ limits ( value )", "def get _ limits ( self , username = None ) :", "`` `` ``", "Return the limits for a given user .", "`` `` ``", "return [ limit . display ( ) for limit in self . levels [ username ] ]", "def check _ for _ delay ( self , verb , url , username = None ) :", "`` `` ``", "Check the given verb / user / user triplet for limit .", "@ return : Tuple of delay ( in seconds ) and error message ( or None , None )", "`` `` ``", "delays = [ ]", "for limit in self . levels [ username ] :", "delay = limit ( verb , url )", "if delay :", "delays . append ( ( delay , limit . error _ message ) )", "if delays :", "delays . sort ( )", "return delays [ 0 ]", "return None , None", "# Note : This method gets called before the class is instantiated ,", "# so this must be either a static method or a class method . It is", "# used to develop a list of limits to feed to the constructor . We", "# put this in the class so that subclasses can override the", "# default limit parsing .", "@ staticmethod", "def parse _ limits ( limits ) :", "`` `` ``", "Convert a string into a list of Limit instances . This", "implementation expects a semicolon - separated sequence of", "parenthesized groups , where each group contains a", "comma - separated sequence consisting of HTTP method ,", "user - readable URI , a URI reg - exp , an integer number of", "requests which can be made , and a unit of measure . Valid", "values for the latter are `` SECOND `` , `` MINUTE `` , `` HOUR `` , and", "`` DAY `` .", "@ return : List of Limit instances .", "`` `` ``", "# Handle empty limit strings", "limits = limits . strip ( )", "if not limits :", "return [ ]", "# Split up the limits by semicolon", "result = [ ]", "for group in limits . split ( ' ; ' ) :", "group = group . strip ( )", "if group [ : 1 ] ! = ' ( ' or group [ - 1 : ] ! = ' ) ' :", "raise ValueError ( `` Limit rules must be surrounded by ``", "`` parentheses `` )", "group = group [ 1 : - 1 ]", "# Extract the Limit arguments", "args = [ a . strip ( ) for a in group . split ( ' , ' ) ]", "if len ( args ) ! = 5 :", "raise ValueError ( `` Limit rules must contain the following ``", "`` arguments : verb , uri , regex , value , unit `` )", "# Pull out the arguments", "verb , uri , regex , value , unit = args", "# Upper - case the verb", "verb = verb . upper ( )", "# Convert value - - raises ValueError if it ' s not integer", "value = int ( value )", "# Convert unit", "unit = unit . upper ( )", "if unit not in Limit . UNIT _ MAP :", "raise ValueError ( `` Invalid units specified `` )", "unit = Limit . UNIT _ MAP [ unit ]", "# Build a limit", "result . append ( Limit ( verb , uri , regex , value , unit ) )", "return result", "class WsgiLimiter ( object ) :", "`` `` ``", "Rate - limit checking from a WSGI application . Uses an in - memory ` Limiter ` .", "To use , POST ` ` / < username > ` ` with JSON data such as : :", "{", "`` verb `` : GET ,", "`` path `` : `` / servers ``", "}", "and receive a 204 No Content , or a 403 Forbidden with an X - Wait - Seconds", "header containing the number of seconds to wait before the action would", "succeed .", "`` `` ``", "def _ _ init _ _ ( self , limits = None ) :", "`` `` ``", "Initialize the new ` WsgiLimiter ` .", "@ param limits : List of ` Limit ` objects", "`` `` ``", "self . _ limiter = Limiter ( limits or DEFAULT _ LIMITS )", "@ webob . dec . wsgify ( RequestClass = wsgi . Request )", "def _ _ call _ _ ( self , request ) :", "`` `` ``", "Handles a call to this application . Returns 204 if the request is", "acceptable to the limiter , else a 403 is returned with a relevant", "header indicating when the request * will * succeed .", "`` `` ``", "if request . method ! = `` POST `` :", "raise webob . exc . HTTPMethodNotAllowed ( )", "try :", "info = dict ( jsonutils . loads ( request . body ) )", "except ValueError :", "raise webob . exc . HTTPBadRequest ( )", "username = request . path _ info _ pop ( )", "verb = info . get ( `` verb `` )", "path = info . get ( `` path `` )", "delay , error = self . _ limiter . check _ for _ delay ( verb , path , username )", "if delay :", "headers = { `` X - Wait - Seconds `` : `` % . 2f `` % delay }", "return webob . exc . HTTPForbidden ( headers = headers , explanation = error )", "else :", "return webob . exc . HTTPNoContent ( )", "class WsgiLimiterProxy ( object ) :", "`` `` ``", "Rate - limit requests based on answers from a remote source .", "`` `` ``", "def _ _ init _ _ ( self , limiter _ address ) :", "`` `` ``", "Initialize the new ` WsgiLimiterProxy ` .", "@ param limiter _ address : IP / port combination of where to request limit", "`` `` ``", "self . limiter _ address = limiter _ address", "def check _ for _ delay ( self , verb , path , username = None ) :", "body = jsonutils . dumps ( { `` verb `` : verb , `` path `` : path } )", "headers = { `` Content - Type `` : `` application / json `` }", "conn = httplib . HTTPConnection ( self . limiter _ address )", "if username :", "conn . request ( `` POST `` , `` / % s `` % ( username ) , body , headers )", "else :", "conn . request ( `` POST `` , `` / `` , body , headers )", "resp = conn . getresponse ( )", "if 200 > = resp . status < 300 :", "return None , None", "return resp . getheader ( `` X - Wait - Seconds `` ) , resp . read ( ) or None", "# Note : This method gets called before the class is instantiated ,", "# so this must be either a static method or a class method . It is", "# used to develop a list of limits to feed to the constructor .", "# This implementation returns an empty list , since all limit", "# decisions are made by a remote server .", "@ staticmethod", "def parse _ limits ( limits ) :", "`` `` ``", "Ignore a limits string - - simply doesn ' t apply for the limit", "proxy .", "@ return : Empty list .", "`` `` ``", "return [ ]", ],"removed_code":[]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2011 OpenStack LLC .", "Copyright 2011 United States Government as represented by the", "Administrator of the National Aeronautics and Space Administration .", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "WSGI middleware for OpenStack Volume API .", "`` `` ``", "from cinder . api import extensions", "import cinder . api . openstack", "from cinder . api . v2 import limits", "from cinder . api . v2 import snapshots", "from cinder . api . v2 import types", "from cinder . api . v2 import volumes", "from cinder . api import versions", "from cinder . openstack . common import log as logging", "LOG = logging . getLogger ( _ _ name _ _ )", "class APIRouter ( cinder . api . openstack . APIRouter ) :", "`` `` ``", "Routes requests on the OpenStack API to the appropriate controller", "and method .", "`` `` ``", "ExtensionManager = extensions . ExtensionManager", "def _ setup _ routes ( self , mapper , ext _ mgr ) :", "self . resources [ ' versions ' ] = versions . create _ resource ( )", "mapper . connect ( `` versions `` , `` / `` ,", "controller = self . resources [ ' versions ' ] ,", "action = ' show ' )", "mapper . redirect ( `` `` , `` / `` )", "self . resources [ ' volumes ' ] = volumes . create _ resource ( ext _ mgr )", "mapper . resource ( `` volume `` , `` volumes `` ,", "controller = self . resources [ ' volumes ' ] ,", "collection = { ' detail ' : ' GET ' } ,", "member = { ' action ' : ' POST ' } )", "self . resources [ ' types ' ] = types . create _ resource ( )", "mapper . resource ( `` type `` , `` types `` ,", "controller = self . resources [ ' types ' ] )", "self . resources [ ' snapshots ' ] = snapshots . create _ resource ( ext _ mgr )", "mapper . resource ( `` snapshot `` , `` snapshots `` ,", "controller = self . resources [ ' snapshots ' ] ,", "collection = { ' detail ' : ' GET ' } ,", "member = { ' action ' : ' POST ' } )", "self . resources [ ' limits ' ] = limits . create _ resource ( )", "mapper . resource ( `` limit `` , `` limits `` ,", "controller = self . resources [ ' limits ' ] )", ],"removed_code":[]},{"added_code":["Copyright 2011 Justin Santa Barbara", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` `` The volumes snapshots api . `` `` ``", "import webob", "from webob import exc", "from cinder . api import common", "from cinder . api . openstack import wsgi", "from cinder . api . v2 import volumes", "from cinder . api import xmlutil", "from cinder import exception", "from cinder import flags", "from cinder . openstack . common import log as logging", "from cinder import utils", "from cinder import volume", "LOG = logging . getLogger ( _ _ name _ _ )", "FLAGS = flags . FLAGS", "def _ translate _ snapshot _ detail _ view ( context , snapshot ) :", "`` `` `` Maps keys for snapshots details view . `` `` ``", "d = _ translate _ snapshot _ summary _ view ( context , snapshot )", "# NOTE ( gagupta ) : No additional data / lookups at the moment", "return d", "def _ translate _ snapshot _ summary _ view ( context , snapshot ) :", "`` `` `` Maps keys for snapshots summary view . `` `` ``", "d = { }", "d [ ' id ' ] = snapshot [ ' id ' ]", "d [ ' created _ at ' ] = snapshot [ ' created _ at ' ]", "d [ ' display _ name ' ] = snapshot [ ' display _ name ' ]", "d [ ' display _ description ' ] = snapshot [ ' display _ description ' ]", "d [ ' volume _ id ' ] = snapshot [ ' volume _ id ' ]", "d [ ' status ' ] = snapshot [ ' status ' ]", "d [ ' size ' ] = snapshot [ ' volume _ size ' ]", "return d", "def make _ snapshot ( elem ) :", "elem . set ( ' id ' )", "elem . set ( ' status ' )", "elem . set ( ' size ' )", "elem . set ( ' created _ at ' )", "elem . set ( ' display _ name ' )", "elem . set ( ' display _ description ' )", "elem . set ( ' volume _ id ' )", "class SnapshotTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' snapshot ' , selector = ' snapshot ' )", "make _ snapshot ( root )", "return xmlutil . MasterTemplate ( root , 1 )", "class SnapshotsTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' snapshots ' )", "elem = xmlutil . SubTemplateElement ( root , ' snapshot ' ,", "selector = ' snapshots ' )", "make _ snapshot ( elem )", "return xmlutil . MasterTemplate ( root , 1 )", "class SnapshotsController ( wsgi . Controller ) :", "`` `` `` The Volumes API controller for the OpenStack API . `` `` ``", "def _ _ init _ _ ( self , ext _ mgr = None ) :", "self . volume _ api = volume . API ( )", "self . ext _ mgr = ext _ mgr", "super ( SnapshotsController , self ) . _ _ init _ _ ( )", "@ wsgi . serializers ( xml = SnapshotTemplate )", "def show ( self , req , id ) :", "`` `` `` Return data about the given snapshot . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "try :", "vol = self . volume _ api . get _ snapshot ( context , id )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "return { ' snapshot ' : _ translate _ snapshot _ detail _ view ( context , vol ) }", "def delete ( self , req , id ) :", "`` `` `` Delete a snapshot . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "LOG . audit ( _ ( `` Delete snapshot with id : % s `` ) , id , context = context )", "try :", "snapshot = self . volume _ api . get _ snapshot ( context , id )", "self . volume _ api . delete _ snapshot ( context , snapshot )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "return webob . Response ( status _ int = 202 )", "@ wsgi . serializers ( xml = SnapshotsTemplate )", "def index ( self , req ) :", "`` `` `` Returns a summary list of snapshots . `` `` ``", "return self . _ items ( req , entity _ maker = _ translate _ snapshot _ summary _ view )", "@ wsgi . serializers ( xml = SnapshotsTemplate )", "def detail ( self , req ) :", "`` `` `` Returns a detailed list of snapshots . `` `` ``", "return self . _ items ( req , entity _ maker = _ translate _ snapshot _ detail _ view )", "def _ items ( self , req , entity _ maker ) :", "`` `` `` Returns a list of snapshots , transformed through entity _ maker . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "search _ opts = { }", "search _ opts . update ( req . GET )", "allowed _ search _ options = ( ' status ' , ' volume _ id ' , ' display _ name ' )", "volumes . remove _ invalid _ options ( context , search _ opts ,", "allowed _ search _ options )", "snapshots = self . volume _ api . get _ all _ snapshots ( context ,", "search _ opts = search _ opts )", "limited _ list = common . limited ( snapshots , req )", "res = [ entity _ maker ( context , snapshot ) for snapshot in limited _ list ]", "return { ' snapshots ' : res }", "@ wsgi . serializers ( xml = SnapshotTemplate )", "def create ( self , req , body ) :", "`` `` `` Creates a new snapshot . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "if not self . is _ valid _ body ( body , ' snapshot ' ) :", "raise exc . HTTPUnprocessableEntity ( )", "snapshot = body [ ' snapshot ' ]", "volume _ id = snapshot [ ' volume _ id ' ]", "volume = self . volume _ api . get ( context , volume _ id )", "force = snapshot . get ( ' force ' , False )", "msg = _ ( `` Create snapshot from volume % s `` )", "LOG . audit ( msg , volume _ id , context = context )", "if not utils . is _ valid _ boolstr ( force ) :", "msg = _ ( `` Invalid value ' % s ' for force . `` ) % force", "raise exception . InvalidParameterValue ( err = msg )", "if utils . bool _ from _ str ( force ) :", "new _ snapshot = self . volume _ api . create _ snapshot _ force ( context ,", "volume ,", "snapshot . get ( ' display _ name ' ) ,", "snapshot . get ( ' display _ description ' ) )", "else :", "new _ snapshot = self . volume _ api . create _ snapshot ( context ,", "volume ,", "snapshot . get ( ' display _ name ' ) ,", "snapshot . get ( ' display _ description ' ) )", "retval = _ translate _ snapshot _ detail _ view ( context , new _ snapshot )", "return { ' snapshot ' : retval }", "@ wsgi . serializers ( xml = SnapshotTemplate )", "def update ( self , req , id , body ) :", "`` `` `` Update a snapshot . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "if not body :", "raise exc . HTTPUnprocessableEntity ( )", "if not ' snapshot ' in body :", "raise exc . HTTPUnprocessableEntity ( )", "snapshot = body [ ' snapshot ' ]", "update _ dict = { }", "valid _ update _ keys = (", "' display _ name ' ,", "' display _ description ' ,", ")", "for key in valid _ update _ keys :", "if key in snapshot :", "update _ dict [ key ] = snapshot [ key ]", "try :", "snapshot = self . volume _ api . get _ snapshot ( context , id )", "self . volume _ api . update _ snapshot ( context , snapshot , update _ dict )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "snapshot . update ( update _ dict )", "return { ' snapshot ' : _ translate _ snapshot _ detail _ view ( context , snapshot ) }", "def create _ resource ( ext _ mgr ) :", "return wsgi . Resource ( SnapshotsController ( ext _ mgr ) )", ],"removed_code":[]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright ( c ) 2011 Zadara Storage Inc .", "Copyright ( c ) 2011 OpenStack LLC .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` `` The volume type & volume types extra specs extension `` `` ``", "from webob import exc", "from cinder . api . openstack import wsgi", "from cinder . api . views import types as views _ types", "from cinder . api import xmlutil", "from cinder import exception", "from cinder . volume import volume _ types", "def make _ voltype ( elem ) :", "elem . set ( ' id ' )", "elem . set ( ' name ' )", "extra _ specs = xmlutil . make _ flat _ dict ( ' extra _ specs ' , selector = ' extra _ specs ' )", "elem . append ( extra _ specs )", "class VolumeTypeTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' volume _ type ' , selector = ' volume _ type ' )", "make _ voltype ( root )", "return xmlutil . MasterTemplate ( root , 1 )", "class VolumeTypesTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' volume _ types ' )", "elem = xmlutil . SubTemplateElement ( root , ' volume _ type ' ,", "selector = ' volume _ types ' )", "make _ voltype ( elem )", "return xmlutil . MasterTemplate ( root , 1 )", "class VolumeTypesController ( wsgi . Controller ) :", "`` `` `` The volume types API controller for the OpenStack API `` `` ``", "_ view _ builder _ class = views _ types . ViewBuilder", "@ wsgi . serializers ( xml = VolumeTypesTemplate )", "def index ( self , req ) :", "`` `` `` Returns the list of volume types `` `` ``", "context = req . environ [ ' cinder . context ' ]", "vol _ types = volume _ types . get _ all _ types ( context ) . values ( )", "return self . _ view _ builder . index ( req , vol _ types )", "@ wsgi . serializers ( xml = VolumeTypeTemplate )", "def show ( self , req , id ) :", "`` `` `` Return a single volume type item `` `` ``", "context = req . environ [ ' cinder . context ' ]", "try :", "vol _ type = volume _ types . get _ volume _ type ( context , id )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "# TODO ( bcwaldon ) : remove str cast once we use uuids", "vol _ type [ ' id ' ] = str ( vol _ type [ ' id ' ] )", "return self . _ view _ builder . show ( req , vol _ type )", "def create _ resource ( ) :", "return wsgi . Resource ( VolumeTypesController ( ) )", ],"removed_code":[]},{"added_code":["Copyright 2011 Justin Santa Barbara", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` `` The volumes api . `` `` ``", "import webob", "from webob import exc", "from xml . dom import minidom", "from cinder . api import common", "from cinder . api . openstack import wsgi", "from cinder . api import xmlutil", "from cinder import exception", "from cinder import flags", "from cinder . openstack . common import log as logging", "from cinder . openstack . common import uuidutils", "from cinder import volume", "from cinder . volume import volume _ types", "LOG = logging . getLogger ( _ _ name _ _ )", "FLAGS = flags . FLAGS", "def _ translate _ attachment _ detail _ view ( _ context , vol ) :", "`` `` `` Maps keys for attachment details view . `` `` ``", "d = _ translate _ attachment _ summary _ view ( _ context , vol )", "# No additional data / lookups at the moment", "return d", "def _ translate _ attachment _ summary _ view ( _ context , vol ) :", "`` `` `` Maps keys for attachment summary view . `` `` ``", "d = { }", "volume _ id = vol [ ' id ' ]", "# NOTE ( justinsb ) : We use the volume id as the id of the attachment object", "d [ ' id ' ] = volume _ id", "d [ ' volume _ id ' ] = volume _ id", "d [ ' server _ id ' ] = vol [ ' instance _ uuid ' ]", "if vol . get ( ' mountpoint ' ) :", "d [ ' device ' ] = vol [ ' mountpoint ' ]", "return d", "def _ translate _ volume _ detail _ view ( context , vol , image _ id = None ) :", "`` `` `` Maps keys for volumes details view . `` `` ``", "d = _ translate _ volume _ summary _ view ( context , vol , image _ id )", "# No additional data / lookups at the moment", "return d", "def _ translate _ volume _ summary _ view ( context , vol , image _ id = None ) :", "`` `` `` Maps keys for volumes summary view . `` `` ``", "d = { }", "d [ ' id ' ] = vol [ ' id ' ]", "d [ ' status ' ] = vol [ ' status ' ]", "d [ ' size ' ] = vol [ ' size ' ]", "d [ ' availability _ zone ' ] = vol [ ' availability _ zone ' ]", "d [ ' created _ at ' ] = vol [ ' created _ at ' ]", "d [ ' attachments ' ] = [ ]", "if vol [ ' attach _ status ' ] = = ' attached ' :", "attachment = _ translate _ attachment _ detail _ view ( context , vol )", "d [ ' attachments ' ] . append ( attachment )", "d [ ' display _ name ' ] = vol [ ' display _ name ' ]", "d [ ' display _ description ' ] = vol [ ' display _ description ' ]", "if vol [ ' volume _ type _ id ' ] and vol . get ( ' volume _ type ' ) :", "d [ ' volume _ type ' ] = vol [ ' volume _ type ' ] [ ' name ' ]", "else :", "# TODO ( bcwaldon ) : remove str cast once we use uuids", "d [ ' volume _ type ' ] = str ( vol [ ' volume _ type _ id ' ] )", "d [ ' snapshot _ id ' ] = vol [ ' snapshot _ id ' ]", "if image _ id :", "d [ ' image _ id ' ] = image _ id", "LOG . audit ( _ ( `` vol = % s `` ) , vol , context = context )", "if vol . get ( ' volume _ metadata ' ) :", "metadata = vol . get ( ' volume _ metadata ' )", "d [ ' metadata ' ] = dict ( ( item [ ' key ' ] , item [ ' value ' ] ) for item in metadata )", "# avoid circular ref when vol is a Volume instance", "elif vol . get ( ' metadata ' ) and isinstance ( vol . get ( ' metadata ' ) , dict ) :", "d [ ' metadata ' ] = vol [ ' metadata ' ]", "else :", "d [ ' metadata ' ] = { }", "return d", "def make _ attachment ( elem ) :", "elem . set ( ' id ' )", "elem . set ( ' server _ id ' )", "elem . set ( ' volume _ id ' )", "elem . set ( ' device ' )", "def make _ volume ( elem ) :", "elem . set ( ' id ' )", "elem . set ( ' status ' )", "elem . set ( ' size ' )", "elem . set ( ' availability _ zone ' )", "elem . set ( ' created _ at ' )", "elem . set ( ' display _ name ' )", "elem . set ( ' display _ description ' )", "elem . set ( ' volume _ type ' )", "elem . set ( ' snapshot _ id ' )", "attachments = xmlutil . SubTemplateElement ( elem , ' attachments ' )", "attachment = xmlutil . SubTemplateElement ( attachments , ' attachment ' ,", "selector = ' attachments ' )", "make _ attachment ( attachment )", "# Attach metadata node", "elem . append ( common . MetadataTemplate ( ) )", "volume _ nsmap = { None : xmlutil . XMLNS _ VOLUME _ V2 , ' atom ' : xmlutil . XMLNS _ ATOM }", "class VolumeTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' volume ' , selector = ' volume ' )", "make _ volume ( root )", "return xmlutil . MasterTemplate ( root , 1 , nsmap = volume _ nsmap )", "class VolumesTemplate ( xmlutil . TemplateBuilder ) :", "def construct ( self ) :", "root = xmlutil . TemplateElement ( ' volumes ' )", "elem = xmlutil . SubTemplateElement ( root , ' volume ' , selector = ' volumes ' )", "make _ volume ( elem )", "return xmlutil . MasterTemplate ( root , 1 , nsmap = volume _ nsmap )", "class CommonDeserializer ( wsgi . MetadataXMLDeserializer ) :", "`` `` `` Common deserializer to handle xml - formatted volume requests .", "Handles standard volume attributes as well as the optional metadata", "attribute", "`` `` ``", "metadata _ deserializer = common . MetadataXMLDeserializer ( )", "def _ extract _ volume ( self , node ) :", "`` `` `` Marshal the volume attribute of a parsed request . `` `` ``", "volume = { }", "volume _ node = self . find _ first _ child _ named ( node , ' volume ' )", "attributes = [ ' display _ name ' , ' display _ description ' , ' size ' ,", "' volume _ type ' , ' availability _ zone ' ]", "for attr in attributes :", "if volume _ node . getAttribute ( attr ) :", "volume [ attr ] = volume _ node . getAttribute ( attr )", "metadata _ node = self . find _ first _ child _ named ( volume _ node , ' metadata ' )", "if metadata _ node is not None :", "volume [ ' metadata ' ] = self . extract _ metadata ( metadata _ node )", "return volume", "class CreateDeserializer ( CommonDeserializer ) :", "`` `` `` Deserializer to handle xml - formatted create volume requests .", "Handles standard volume attributes as well as the optional metadata", "attribute", "`` `` ``", "def default ( self , string ) :", "`` `` `` Deserialize an xml - formatted volume create request . `` `` ``", "dom = minidom . parseString ( string )", "volume = self . _ extract _ volume ( dom )", "return { ' body ' : { ' volume ' : volume } }", "class VolumeController ( wsgi . Controller ) :", "`` `` `` The Volumes API controller for the OpenStack API . `` `` ``", "def _ _ init _ _ ( self , ext _ mgr ) :", "self . volume _ api = volume . API ( )", "self . ext _ mgr = ext _ mgr", "super ( VolumeController , self ) . _ _ init _ _ ( )", "@ wsgi . serializers ( xml = VolumeTemplate )", "def show ( self , req , id ) :", "`` `` `` Return data about the given volume . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "try :", "vol = self . volume _ api . get ( context , id )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "return { ' volume ' : _ translate _ volume _ detail _ view ( context , vol ) }", "def delete ( self , req , id ) :", "`` `` `` Delete a volume . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "LOG . audit ( _ ( `` Delete volume with id : % s `` ) , id , context = context )", "try :", "volume = self . volume _ api . get ( context , id )", "self . volume _ api . delete ( context , volume )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "return webob . Response ( status _ int = 202 )", "@ wsgi . serializers ( xml = VolumesTemplate )", "def index ( self , req ) :", "`` `` `` Returns a summary list of volumes . `` `` ``", "return self . _ items ( req , entity _ maker = _ translate _ volume _ summary _ view )", "@ wsgi . serializers ( xml = VolumesTemplate )", "def detail ( self , req ) :", "`` `` `` Returns a detailed list of volumes . `` `` ``", "return self . _ items ( req , entity _ maker = _ translate _ volume _ detail _ view )", "def _ items ( self , req , entity _ maker ) :", "`` `` `` Returns a list of volumes , transformed through entity _ maker . `` `` ``", "search _ opts = { }", "search _ opts . update ( req . GET )", "context = req . environ [ ' cinder . context ' ]", "remove _ invalid _ options ( context ,", "search _ opts , self . _ get _ volume _ search _ options ( ) )", "volumes = self . volume _ api . get _ all ( context , search _ opts = search _ opts )", "limited _ list = common . limited ( volumes , req )", "res = [ entity _ maker ( context , vol ) for vol in limited _ list ]", "return { ' volumes ' : res }", "def _ image _ uuid _ from _ href ( self , image _ href ) :", "# If the image href was generated by nova api , strip image _ href", "# down to an id .", "try :", "image _ uuid = image _ href . split ( ' / ' ) . pop ( )", "except ( TypeError , AttributeError ) :", "msg = _ ( `` Invalid imageRef provided . `` )", "raise exc . HTTPBadRequest ( explanation = msg )", "if not uuidutils . is _ uuid _ like ( image _ uuid ) :", "msg = _ ( `` Invalid imageRef provided . `` )", "raise exc . HTTPBadRequest ( explanation = msg )", "return image _ uuid", "@ wsgi . serializers ( xml = VolumeTemplate )", "@ wsgi . deserializers ( xml = CreateDeserializer )", "def create ( self , req , body ) :", "`` `` `` Creates a new volume . `` `` ``", "if not self . is _ valid _ body ( body , ' volume ' ) :", "raise exc . HTTPUnprocessableEntity ( )", "context = req . environ [ ' cinder . context ' ]", "volume = body [ ' volume ' ]", "kwargs = { }", "req _ volume _ type = volume . get ( ' volume _ type ' , None )", "if req _ volume _ type :", "try :", "kwargs [ ' volume _ type ' ] = volume _ types . get _ volume _ type _ by _ name (", "context , req _ volume _ type )", "except exception . VolumeTypeNotFound :", "explanation = ' Volume type not found . '", "raise exc . HTTPNotFound ( explanation = explanation )", "kwargs [ ' metadata ' ] = volume . get ( ' metadata ' , None )", "snapshot _ id = volume . get ( ' snapshot _ id ' )", "if snapshot _ id is not None :", "kwargs [ ' snapshot ' ] = self . volume _ api . get _ snapshot ( context ,", "snapshot _ id )", "else :", "kwargs [ ' snapshot ' ] = None", "size = volume . get ( ' size ' , None )", "if size is None and kwargs [ ' snapshot ' ] is not None :", "size = kwargs [ ' snapshot ' ] [ ' volume _ size ' ]", "LOG . audit ( _ ( `` Create volume of % s GB `` ) , size , context = context )", "image _ href = None", "image _ uuid = None", "if self . ext _ mgr . is _ loaded ( ' os - image - create ' ) :", "image _ href = volume . get ( ' imageRef ' )", "if snapshot _ id and image _ href :", "msg = _ ( `` Snapshot and image can not be specified together . `` )", "raise exc . HTTPBadRequest ( explanation = msg )", "if image _ href :", "image _ uuid = self . _ image _ uuid _ from _ href ( image _ href )", "kwargs [ ' image _ id ' ] = image _ uuid", "kwargs [ ' availability _ zone ' ] = volume . get ( ' availability _ zone ' , None )", "new _ volume = self . volume _ api . create ( context ,", "size ,", "volume . get ( ' display _ name ' ) ,", "volume . get ( ' display _ description ' ) ,", "* * kwargs )", "# TODO ( vish ) : Instance should be None at db layer instead of", "# trying to lazy load , but for now we turn it into", "# a dict to avoid an error .", "retval = _ translate _ volume _ detail _ view ( context ,", "dict ( new _ volume . iteritems ( ) ) ,", "image _ uuid )", "return { ' volume ' : retval }", "def _ get _ volume _ search _ options ( self ) :", "`` `` `` Return volume search options allowed by non - admin . `` `` ``", "return ( ' display _ name ' , ' status ' )", "@ wsgi . serializers ( xml = VolumeTemplate )", "def update ( self , req , id , body ) :", "`` `` `` Update a volume . `` `` ``", "context = req . environ [ ' cinder . context ' ]", "if not body :", "raise exc . HTTPUnprocessableEntity ( )", "if not ' volume ' in body :", "raise exc . HTTPUnprocessableEntity ( )", "volume = body [ ' volume ' ]", "update _ dict = { }", "valid _ update _ keys = (", "' display _ name ' ,", "' display _ description ' ,", "' metadata ' ,", ")", "for key in valid _ update _ keys :", "if key in volume :", "update _ dict [ key ] = volume [ key ]", "try :", "volume = self . volume _ api . get ( context , id )", "self . volume _ api . update ( context , volume , update _ dict )", "except exception . NotFound :", "raise exc . HTTPNotFound ( )", "volume . update ( update _ dict )", "return { ' volume ' : _ translate _ volume _ detail _ view ( context , volume ) }", "def create _ resource ( ext _ mgr ) :", "return wsgi . Resource ( VolumeController ( ext _ mgr ) )", "def remove _ invalid _ options ( context , search _ options , allowed _ search _ options ) :", "`` `` `` Remove search options that are not valid for non - admin API / context . `` `` ``", "if context . is _ admin :", "# Allow all options", "return", "# Otherwise , strip out all unknown options", "unknown _ options = [ opt for opt in search _ options", "if opt not in allowed _ search _ options ]", "bad _ options = `` , `` . join ( unknown _ options )", "log _ msg = _ ( `` Removing options ' % ( bad _ options ) s ' from query `` ) % locals ( )", "LOG . debug ( log _ msg )", "for opt in unknown _ options :", "del search _ options [ opt ]", ],"removed_code":[]},{"added_code":["`` v2 . 0 `` : {", "`` id `` : `` v2 . 0 `` ,", "`` status `` : `` CURRENT `` ,", "`` updated `` : `` 2012 - 11 - 21T11 : 33 : 21Z `` ,", "`` links `` : [", "{", "`` rel `` : `` describedby `` ,", "`` type `` : `` application / pdf `` ,", "`` href `` : `` http : / / jorgew . github . com / block - storage - api / ``", "`` content / os - block - storage - 1 . 0 . pdf `` ,", "} ,", "{", "`` rel `` : `` describedby `` ,", "`` type `` : `` application / vnd . sun . wadl + xml `` ,", "# ( anthony ) FIXME", "`` href `` : `` http : / / docs . rackspacecloud . com / ``", "`` servers / api / v1 . 1 / application . wadl `` ,", "} ,", "] ,", "`` media - types `` : [", "{", "`` base `` : `` application / xml `` ,", "`` type `` : `` application / vnd . openstack . volume + xml ; version = 1 `` ,", "} ,", "{", "`` base `` : `` application / json `` ,", "`` type `` : `` application / vnd . openstack . volume + json ; version = 1 `` ,", "}", "] ,", "} ,", ],"removed_code":[]},{"added_code":["XMLNS _ VOLUME _ V2 = ( ' http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / '", "' content ' )", ],"removed_code":[]},{"added_code":["cfg . BoolOpt ( ' enable _ v1 _ api ' ,", "default = True ,", "help = _ ( `` Deploy v1 of the Cinder API . `` ) ) ,", "cfg . BoolOpt ( ' enable _ v2 _ api ' ,", "default = True ,", "help = _ ( `` Deploy v2 of the Cinder API . `` ) ) ,", ],"removed_code":["cfg . BoolOpt ( ' enable _ v1 _ api ' , default = True ,", "help = _ ( `` Deploy v1 of the Cinder API `` ) ) ,", "cfg . BoolOpt ( ' enable _ v2 _ api ' , default = True ,", "help = _ ( `` Deploy v2 of the Cinder API `` ) ) ,", ]},{"added_code":[],"removed_code":[]},{"added_code":["Copyright 2011 OpenStack LLC .", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Tests dealing with HTTP rate - limiting .", "`` `` ``", "import httplib", "import StringIO", "from lxml import etree", "import webob", "from xml . dom import minidom", "from cinder . api . v2 import limits", "from cinder . api import views", "from cinder . api import xmlutil", "import cinder . context", "from cinder . openstack . common import jsonutils", "from cinder import test", "TEST _ LIMITS = [", "limits . Limit ( `` GET `` , `` / delayed `` , `` ^ / delayed `` , 1 , limits . PER _ MINUTE ) ,", "limits . Limit ( `` POST `` , `` * `` , `` . * `` , 7 , limits . PER _ MINUTE ) ,", "limits . Limit ( `` POST `` , `` / volumes `` , `` ^ / volumes `` , 3 , limits . PER _ MINUTE ) ,", "limits . Limit ( `` PUT `` , `` * `` , `` `` , 10 , limits . PER _ MINUTE ) ,", "limits . Limit ( `` PUT `` , `` / volumes `` , `` ^ / volumes `` , 5 , limits . PER _ MINUTE ) ,", "]", "NS = {", "' atom ' : ' http : / / www . w3 . org / 2005 / Atom ' ,", "' ns ' : ' http : / / docs . openstack . org / common / api / v1 . 0 ' ,", "}", "class BaseLimitTestSuite ( test . TestCase ) :", "`` `` `` Base test suite which provides relevant stubs and time abstraction . `` `` ``", "def setUp ( self ) :", "super ( BaseLimitTestSuite , self ) . setUp ( )", "self . time = 0 . 0", "self . stubs . Set ( limits . Limit , `` _ get _ time `` , self . _ get _ time )", "self . absolute _ limits = { }", "def stub _ get _ project _ quotas ( context , project _ id , usages = True ) :", "return dict ( ( k , dict ( limit = v ) )", "for k , v in self . absolute _ limits . items ( ) )", "self . stubs . Set ( cinder . quota . QUOTAS , `` get _ project _ quotas `` ,", "stub _ get _ project _ quotas )", "def _ get _ time ( self ) :", "`` `` `` Return the `` time `` according to this test suite . `` `` ``", "return self . time", "class LimitsControllerTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for ` limits . LimitsController ` class .", "`` `` ``", "def setUp ( self ) :", "`` `` `` Run before each test . `` `` ``", "super ( LimitsControllerTest , self ) . setUp ( )", "self . controller = limits . create _ resource ( )", "def _ get _ index _ request ( self , accept _ header = `` application / json `` ) :", "`` `` `` Helper to set routing arguments . `` `` ``", "request = webob . Request . blank ( `` / `` )", "request . accept = accept _ header", "request . environ [ `` wsgiorg . routing _ args `` ] = ( None , {", "`` action `` : `` index `` ,", "`` controller `` : `` `` ,", "} )", "context = cinder . context . RequestContext ( ' testuser ' , ' testproject ' )", "request . environ [ `` cinder . context `` ] = context", "return request", "def _ populate _ limits ( self , request ) :", "`` `` `` Put limit info into a request . `` `` ``", "_ limits = [", "limits . Limit ( `` GET `` , `` * `` , `` . * `` , 10 , 60 ) . display ( ) ,", "limits . Limit ( `` POST `` , `` * `` , `` . * `` , 5 , 60 * 60 ) . display ( ) ,", "limits . Limit ( `` GET `` , `` changes - since * `` , `` changes - since `` ,", "5 , 60 ) . display ( ) ,", "]", "request . environ [ `` cinder . limits `` ] = _ limits", "return request", "def test _ empty _ index _ json ( self ) :", "`` `` `` Test getting empty limit details in JSON . `` `` ``", "request = self . _ get _ index _ request ( )", "response = request . get _ response ( self . controller )", "expected = {", "`` limits `` : {", "`` rate `` : [ ] ,", "`` absolute `` : { } ,", "} ,", "}", "body = jsonutils . loads ( response . body )", "self . assertEqual ( expected , body )", "def test _ index _ json ( self ) :", "`` `` `` Test getting limit details in JSON . `` `` ``", "request = self . _ get _ index _ request ( )", "request = self . _ populate _ limits ( request )", "self . absolute _ limits = {", "' gigabytes ' : 512 ,", "' volumes ' : 5 ,", "}", "response = request . get _ response ( self . controller )", "expected = {", "`` limits `` : {", "`` rate `` : [", "{", "`` regex `` : `` . * `` ,", "`` uri `` : `` * `` ,", "`` limit `` : [", "{", "`` verb `` : `` GET `` ,", "`` next - available `` : `` 1970 - 01 - 01T00 : 00 : 00Z `` ,", "`` unit `` : `` MINUTE `` ,", "`` value `` : 10 ,", "`` remaining `` : 10 ,", "} ,", "{", "`` verb `` : `` POST `` ,", "`` next - available `` : `` 1970 - 01 - 01T00 : 00 : 00Z `` ,", "`` unit `` : `` HOUR `` ,", "`` value `` : 5 ,", "`` remaining `` : 5 ,", "} ,", "] ,", "} ,", "{", "`` regex `` : `` changes - since `` ,", "`` uri `` : `` changes - since * `` ,", "`` limit `` : [", "{", "`` verb `` : `` GET `` ,", "`` next - available `` : `` 1970 - 01 - 01T00 : 00 : 00Z `` ,", "`` unit `` : `` MINUTE `` ,", "`` value `` : 5 ,", "`` remaining `` : 5 ,", "} ,", "] ,", "} ,", "] ,", "`` absolute `` : {", "`` maxTotalVolumeGigabytes `` : 512 ,", "`` maxTotalVolumes `` : 5 ,", "} ,", "} ,", "}", "body = jsonutils . loads ( response . body )", "self . assertEqual ( expected , body )", "def _ populate _ limits _ diff _ regex ( self , request ) :", "`` `` `` Put limit info into a request . `` `` ``", "_ limits = [", "limits . Limit ( `` GET `` , `` * `` , `` . * `` , 10 , 60 ) . display ( ) ,", "limits . Limit ( `` GET `` , `` * `` , `` * . * `` , 10 , 60 ) . display ( ) ,", "]", "request . environ [ `` cinder . limits `` ] = _ limits", "return request", "def test _ index _ diff _ regex ( self ) :", "`` `` `` Test getting limit details in JSON . `` `` ``", "request = self . _ get _ index _ request ( )", "request = self . _ populate _ limits _ diff _ regex ( request )", "response = request . get _ response ( self . controller )", "expected = {", "`` limits `` : {", "`` rate `` : [", "{", "`` regex `` : `` . * `` ,", "`` uri `` : `` * `` ,", "`` limit `` : [", "{", "`` verb `` : `` GET `` ,", "`` next - available `` : `` 1970 - 01 - 01T00 : 00 : 00Z `` ,", "`` unit `` : `` MINUTE `` ,", "`` value `` : 10 ,", "`` remaining `` : 10 ,", "} ,", "] ,", "} ,", "{", "`` regex `` : `` * . * `` ,", "`` uri `` : `` * `` ,", "`` limit `` : [", "{", "`` verb `` : `` GET `` ,", "`` next - available `` : `` 1970 - 01 - 01T00 : 00 : 00Z `` ,", "`` unit `` : `` MINUTE `` ,", "`` value `` : 10 ,", "`` remaining `` : 10 ,", "} ,", "] ,", "} ,", "] ,", "`` absolute `` : { } ,", "} ,", "}", "body = jsonutils . loads ( response . body )", "self . assertEqual ( expected , body )", "def _ test _ index _ absolute _ limits _ json ( self , expected ) :", "request = self . _ get _ index _ request ( )", "response = request . get _ response ( self . controller )", "body = jsonutils . loads ( response . body )", "self . assertEqual ( expected , body [ ' limits ' ] [ ' absolute ' ] )", "def test _ index _ ignores _ extra _ absolute _ limits _ json ( self ) :", "self . absolute _ limits = { ' unknown _ limit ' : 9001 }", "self . _ test _ index _ absolute _ limits _ json ( { } )", "class TestLimiter ( limits . Limiter ) :", "pass", "class LimitMiddlewareTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for the ` limits . RateLimitingMiddleware ` class .", "`` `` ``", "@ webob . dec . wsgify", "def _ empty _ app ( self , request ) :", "`` `` `` Do - nothing WSGI app . `` `` ``", "pass", "def setUp ( self ) :", "`` `` `` Prepare middleware for use through fake WSGI app . `` `` ``", "super ( LimitMiddlewareTest , self ) . setUp ( )", "_ limits = ' ( GET , * , . * , 1 , MINUTE ) '", "self . app = limits . RateLimitingMiddleware ( self . _ empty _ app , _ limits ,", "`` % s . TestLimiter `` %", "self . _ _ class _ _ . _ _ module _ _ )", "def test _ limit _ class ( self ) :", "`` `` `` Test that middleware selected correct limiter class . `` `` ``", "assert isinstance ( self . app . _ limiter , TestLimiter )", "def test _ good _ request ( self ) :", "`` `` `` Test successful GET request through middleware . `` `` ``", "request = webob . Request . blank ( `` / `` )", "response = request . get _ response ( self . app )", "self . assertEqual ( 200 , response . status _ int )", "def test _ limited _ request _ json ( self ) :", "`` `` `` Test a rate - limited ( 413 ) GET request through middleware . `` `` ``", "request = webob . Request . blank ( `` / `` )", "response = request . get _ response ( self . app )", "self . assertEqual ( 200 , response . status _ int )", "request = webob . Request . blank ( `` / `` )", "response = request . get _ response ( self . app )", "self . assertEqual ( response . status _ int , 413 )", "self . assertTrue ( ' Retry - After ' in response . headers )", "retry _ after = int ( response . headers [ ' Retry - After ' ] )", "self . assertAlmostEqual ( retry _ after , 60 , 1 )", "body = jsonutils . loads ( response . body )", "expected = `` Only 1 GET request ( s ) can be made to * every minute . ``", "value = body [ `` overLimitFault `` ] [ `` details `` ] . strip ( )", "self . assertEqual ( value , expected )", "def test _ limited _ request _ xml ( self ) :", "`` `` `` Test a rate - limited ( 413 ) response as XML `` `` ``", "request = webob . Request . blank ( `` / `` )", "response = request . get _ response ( self . app )", "self . assertEqual ( 200 , response . status _ int )", "request = webob . Request . blank ( `` / `` )", "request . accept = `` application / xml ``", "response = request . get _ response ( self . app )", "self . assertEqual ( response . status _ int , 413 )", "root = minidom . parseString ( response . body ) . childNodes [ 0 ]", "expected = `` Only 1 GET request ( s ) can be made to * every minute . ``", "details = root . getElementsByTagName ( `` details `` )", "self . assertEqual ( details . length , 1 )", "value = details . item ( 0 ) . firstChild . data . strip ( )", "self . assertEqual ( value , expected )", "class LimitTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for the ` limits . Limit ` class .", "`` `` ``", "def test _ GET _ no _ delay ( self ) :", "`` `` `` Test a limit handles 1 GET per second . `` `` ``", "limit = limits . Limit ( `` GET `` , `` * `` , `` . * `` , 1 , 1 )", "delay = limit ( `` GET `` , `` / anything `` )", "self . assertEqual ( None , delay )", "self . assertEqual ( 0 , limit . next _ request )", "self . assertEqual ( 0 , limit . last _ request )", "def test _ GET _ delay ( self ) :", "`` `` `` Test two calls to 1 GET per second limit . `` `` ``", "limit = limits . Limit ( `` GET `` , `` * `` , `` . * `` , 1 , 1 )", "delay = limit ( `` GET `` , `` / anything `` )", "self . assertEqual ( None , delay )", "delay = limit ( `` GET `` , `` / anything `` )", "self . assertEqual ( 1 , delay )", "self . assertEqual ( 1 , limit . next _ request )", "self . assertEqual ( 0 , limit . last _ request )", "self . time + = 4", "delay = limit ( `` GET `` , `` / anything `` )", "self . assertEqual ( None , delay )", "self . assertEqual ( 4 , limit . next _ request )", "self . assertEqual ( 4 , limit . last _ request )", "class ParseLimitsTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for the default limits parser in the in - memory", "` limits . Limiter ` class .", "`` `` ``", "def test _ invalid ( self ) :", "`` `` `` Test that parse _ limits ( ) handles invalid input correctly . `` `` ``", "self . assertRaises ( ValueError , limits . Limiter . parse _ limits ,", "' ; ; ; ; ; ' )", "def test _ bad _ rule ( self ) :", "`` `` `` Test that parse _ limits ( ) handles bad rules correctly . `` `` ``", "self . assertRaises ( ValueError , limits . Limiter . parse _ limits ,", "' GET , * , . * , 20 , minute ' )", "def test _ missing _ arg ( self ) :", "`` `` `` Test that parse _ limits ( ) handles missing args correctly . `` `` ``", "self . assertRaises ( ValueError , limits . Limiter . parse _ limits ,", "' ( GET , * , . * , 20 ) ' )", "def test _ bad _ value ( self ) :", "`` `` `` Test that parse _ limits ( ) handles bad values correctly . `` `` ``", "self . assertRaises ( ValueError , limits . Limiter . parse _ limits ,", "' ( GET , * , . * , foo , minute ) ' )", "def test _ bad _ unit ( self ) :", "`` `` `` Test that parse _ limits ( ) handles bad units correctly . `` `` ``", "self . assertRaises ( ValueError , limits . Limiter . parse _ limits ,", "' ( GET , * , . * , 20 , lightyears ) ' )", "def test _ multiple _ rules ( self ) :", "`` `` `` Test that parse _ limits ( ) handles multiple rules correctly . `` `` ``", "try :", "l = limits . Limiter . parse _ limits ( ' ( get , * , . * , 20 , minute ) ; '", "' ( PUT , / foo * , / foo . * , 10 , hour ) ; '", "' ( POST , / bar * , / bar . * , 5 , second ) ; '", "' ( Say , / derp * , / derp . * , 1 , day ) ' )", "except ValueError , e :", "assert False , str ( e )", "# Make sure the number of returned limits are correct", "self . assertEqual ( len ( l ) , 4 )", "# Check all the verbs . . .", "expected = [ ' GET ' , ' PUT ' , ' POST ' , ' SAY ' ]", "self . assertEqual ( [ t . verb for t in l ] , expected )", "# . . . the URIs . . .", "expected = [ ' * ' , ' / foo * ' , ' / bar * ' , ' / derp * ' ]", "self . assertEqual ( [ t . uri for t in l ] , expected )", "# . . . the regexes . . .", "expected = [ ' . * ' , ' / foo . * ' , ' / bar . * ' , ' / derp . * ' ]", "self . assertEqual ( [ t . regex for t in l ] , expected )", "# . . . the values . . .", "expected = [ 20 , 10 , 5 , 1 ]", "self . assertEqual ( [ t . value for t in l ] , expected )", "# . . . and the units . . .", "expected = [ limits . PER _ MINUTE , limits . PER _ HOUR ,", "limits . PER _ SECOND , limits . PER _ DAY ]", "self . assertEqual ( [ t . unit for t in l ] , expected )", "class LimiterTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for the in - memory ` limits . Limiter ` class .", "`` `` ``", "def setUp ( self ) :", "`` `` `` Run before each test . `` `` ``", "super ( LimiterTest , self ) . setUp ( )", "userlimits = { ' user : user3 ' : ' ' }", "self . limiter = limits . Limiter ( TEST _ LIMITS , * * userlimits )", "def _ check ( self , num , verb , url , username = None ) :", "`` `` `` Check and yield results from checks . `` `` ``", "for x in xrange ( num ) :", "yield self . limiter . check _ for _ delay ( verb , url , username ) [ 0 ]", "def _ check _ sum ( self , num , verb , url , username = None ) :", "`` `` `` Check and sum results from checks . `` `` ``", "results = self . _ check ( num , verb , url , username )", "return sum ( item for item in results if item )", "def test _ no _ delay _ GET ( self ) :", "`` `` ``", "Simple test to ensure no delay on a single call for a limit verb we", "didn `` t set .", "`` `` ``", "delay = self . limiter . check _ for _ delay ( `` GET `` , `` / anything `` )", "self . assertEqual ( delay , ( None , None ) )", "def test _ no _ delay _ PUT ( self ) :", "`` `` ``", "Simple test to ensure no delay on a single call for a known limit .", "`` `` ``", "delay = self . limiter . check _ for _ delay ( `` PUT `` , `` / anything `` )", "self . assertEqual ( delay , ( None , None ) )", "def test _ delay _ PUT ( self ) :", "`` `` ``", "Ensure the 11th PUT will result in a delay of 6 . 0 seconds until", "the next request will be granced .", "`` `` ``", "expected = [ None ] * 10 + [ 6 . 0 ]", "results = list ( self . _ check ( 11 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "def test _ delay _ POST ( self ) :", "`` `` ``", "Ensure the 8th POST will result in a delay of 6 . 0 seconds until", "the next request will be granced .", "`` `` ``", "expected = [ None ] * 7", "results = list ( self . _ check ( 7 , `` POST `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "expected = 60 . 0 / 7 . 0", "results = self . _ check _ sum ( 1 , `` POST `` , `` / anything `` )", "self . failUnlessAlmostEqual ( expected , results , 8 )", "def test _ delay _ GET ( self ) :", "`` `` ``", "Ensure the 11th GET will result in NO delay .", "`` `` ``", "expected = [ None ] * 11", "results = list ( self . _ check ( 11 , `` GET `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "def test _ delay _ PUT _ volumes ( self ) :", "`` `` ``", "Ensure PUT on / volumes limits at 5 requests , and PUT elsewhere is still", "OK after 5 requests . . . but then after 11 total requests , PUT limiting", "kicks in .", "`` `` ``", "# First 6 requests on PUT / volumes", "expected = [ None ] * 5 + [ 12 . 0 ]", "results = list ( self . _ check ( 6 , `` PUT `` , `` / volumes `` ) )", "self . assertEqual ( expected , results )", "# Next 5 request on PUT / anything", "expected = [ None ] * 4 + [ 6 . 0 ]", "results = list ( self . _ check ( 5 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "def test _ delay _ PUT _ wait ( self ) :", "`` `` ``", "Ensure after hitting the limit and then waiting for the correct", "amount of time , the limit will be lifted .", "`` `` ``", "expected = [ None ] * 10 + [ 6 . 0 ]", "results = list ( self . _ check ( 11 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "# Advance time", "self . time + = 6 . 0", "expected = [ None , 6 . 0 ]", "results = list ( self . _ check ( 2 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "def test _ multiple _ delays ( self ) :", "`` `` ``", "Ensure multiple requests still get a delay .", "`` `` ``", "expected = [ None ] * 10 + [ 6 . 0 ] * 10", "results = list ( self . _ check ( 20 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "self . time + = 1 . 0", "expected = [ 5 . 0 ] * 10", "results = list ( self . _ check ( 10 , `` PUT `` , `` / anything `` ) )", "self . assertEqual ( expected , results )", "def test _ user _ limit ( self ) :", "`` `` ``", "Test user - specific limits .", "`` `` ``", "self . assertEqual ( self . limiter . levels [ ' user3 ' ] , [ ] )", "def test _ multiple _ users ( self ) :", "`` `` ``", "Tests involving multiple users .", "`` `` ``", "# User1", "expected = [ None ] * 10 + [ 6 . 0 ] * 10", "results = list ( self . _ check ( 20 , `` PUT `` , `` / anything `` , `` user1 `` ) )", "self . assertEqual ( expected , results )", "# User2", "expected = [ None ] * 10 + [ 6 . 0 ] * 5", "results = list ( self . _ check ( 15 , `` PUT `` , `` / anything `` , `` user2 `` ) )", "self . assertEqual ( expected , results )", "# User3", "expected = [ None ] * 20", "results = list ( self . _ check ( 20 , `` PUT `` , `` / anything `` , `` user3 `` ) )", "self . assertEqual ( expected , results )", "self . time + = 1 . 0", "# User1 again", "expected = [ 5 . 0 ] * 10", "results = list ( self . _ check ( 10 , `` PUT `` , `` / anything `` , `` user1 `` ) )", "self . assertEqual ( expected , results )", "self . time + = 1 . 0", "# User1 again", "expected = [ 4 . 0 ] * 5", "results = list ( self . _ check ( 5 , `` PUT `` , `` / anything `` , `` user2 `` ) )", "self . assertEqual ( expected , results )", "class WsgiLimiterTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for ` limits . WsgiLimiter ` class .", "`` `` ``", "def setUp ( self ) :", "`` `` `` Run before each test . `` `` ``", "super ( WsgiLimiterTest , self ) . setUp ( )", "self . app = limits . WsgiLimiter ( TEST _ LIMITS )", "def _ request _ data ( self , verb , path ) :", "`` `` `` Get data decribing a limit request verb / path . `` `` ``", "return jsonutils . dumps ( { `` verb `` : verb , `` path `` : path } )", "def _ request ( self , verb , url , username = None ) :", "`` `` `` Make sure that POSTing to the given url causes the given username", "to perform the given action . Make the internal rate limiter return", "delay and make sure that the WSGI app returns the correct response .", "`` `` ``", "if username :", "request = webob . Request . blank ( `` / % s `` % username )", "else :", "request = webob . Request . blank ( `` / `` )", "request . method = `` POST ``", "request . body = self . _ request _ data ( verb , url )", "response = request . get _ response ( self . app )", "if `` X - Wait - Seconds `` in response . headers :", "self . assertEqual ( response . status _ int , 403 )", "return response . headers [ `` X - Wait - Seconds `` ]", "self . assertEqual ( response . status _ int , 204 )", "def test _ invalid _ methods ( self ) :", "`` `` `` Only POSTs should work . `` `` ``", "requests = [ ]", "for method in [ `` GET `` , `` PUT `` , `` DELETE `` , `` HEAD `` , `` OPTIONS `` ] :", "request = webob . Request . blank ( `` / `` , method = method )", "response = request . get _ response ( self . app )", "self . assertEqual ( response . status _ int , 405 )", "def test _ good _ url ( self ) :", "delay = self . _ request ( `` GET `` , `` / something `` )", "self . assertEqual ( delay , None )", "def test _ escaping ( self ) :", "delay = self . _ request ( `` GET `` , `` / something / jump % 20up `` )", "self . assertEqual ( delay , None )", "def test _ response _ to _ delays ( self ) :", "delay = self . _ request ( `` GET `` , `` / delayed `` )", "self . assertEqual ( delay , None )", "delay = self . _ request ( `` GET `` , `` / delayed `` )", "self . assertEqual ( delay , ' 60 . 00 ' )", "def test _ response _ to _ delays _ usernames ( self ) :", "delay = self . _ request ( `` GET `` , `` / delayed `` , `` user1 `` )", "self . assertEqual ( delay , None )", "delay = self . _ request ( `` GET `` , `` / delayed `` , `` user2 `` )", "self . assertEqual ( delay , None )", "delay = self . _ request ( `` GET `` , `` / delayed `` , `` user1 `` )", "self . assertEqual ( delay , ' 60 . 00 ' )", "delay = self . _ request ( `` GET `` , `` / delayed `` , `` user2 `` )", "self . assertEqual ( delay , ' 60 . 00 ' )", "class FakeHttplibSocket ( object ) :", "`` `` ``", "Fake ` httplib . HTTPResponse ` replacement .", "`` `` ``", "def _ _ init _ _ ( self , response _ string ) :", "`` `` `` Initialize new ` FakeHttplibSocket ` . `` `` ``", "self . _ buffer = StringIO . StringIO ( response _ string )", "def makefile ( self , _ mode , _ other ) :", "`` `` `` Returns the socket ' s internal buffer . `` `` ``", "return self . _ buffer", "class FakeHttplibConnection ( object ) :", "`` `` ``", "Fake ` httplib . HTTPConnection ` .", "`` `` ``", "def _ _ init _ _ ( self , app , host ) :", "`` `` ``", "Initialize ` FakeHttplibConnection ` .", "`` `` ``", "self . app = app", "self . host = host", "def request ( self , method , path , body = `` `` , headers = None ) :", "`` `` ``", "Requests made via this connection actually get translated and routed", "into our WSGI app , we then wait for the response and turn it back into", "an ` httplib . HTTPResponse ` .", "`` `` ``", "if not headers :", "headers = { }", "req = webob . Request . blank ( path )", "req . method = method", "req . headers = headers", "req . host = self . host", "req . body = body", "resp = str ( req . get _ response ( self . app ) )", "resp = `` HTTP / 1 . 0 % s `` % resp", "sock = FakeHttplibSocket ( resp )", "self . http _ response = httplib . HTTPResponse ( sock )", "self . http _ response . begin ( )", "def getresponse ( self ) :", "`` `` `` Return our generated response from the request . `` `` ``", "return self . http _ response", "def wire _ HTTPConnection _ to _ WSGI ( host , app ) :", "`` `` `` Monkeypatches HTTPConnection so that if you try to connect to host , you", "are instead routed straight to the given WSGI app .", "After calling this method , when any code calls", "httplib . HTTPConnection ( host )", "the connection object will be a fake . Its requests will be sent directly", "to the given WSGI app rather than through a socket .", "Code connecting to hosts other than host will not be affected .", "This method may be called multiple times to map different hosts to", "different apps .", "This method returns the original HTTPConnection object , so that the caller", "can restore the default HTTPConnection interface ( for all hosts ) .", "`` `` ``", "class HTTPConnectionDecorator ( object ) :", "`` `` `` Wraps the real HTTPConnection class so that when you instantiate", "the class you might instead get a fake instance . `` `` ``", "def _ _ init _ _ ( self , wrapped ) :", "self . wrapped = wrapped", "def _ _ call _ _ ( self , connection _ host , * args , * * kwargs ) :", "if connection _ host = = host :", "return FakeHttplibConnection ( app , host )", "else :", "return self . wrapped ( connection _ host , * args , * * kwargs )", "oldHTTPConnection = httplib . HTTPConnection", "httplib . HTTPConnection = HTTPConnectionDecorator ( httplib . HTTPConnection )", "return oldHTTPConnection", "class WsgiLimiterProxyTest ( BaseLimitTestSuite ) :", "`` `` ``", "Tests for the ` limits . WsgiLimiterProxy ` class .", "`` `` ``", "def setUp ( self ) :", "`` `` ``", "Do some nifty HTTP / WSGI magic which allows for WSGI to be called", "directly by something like the ` httplib ` library .", "`` `` ``", "super ( WsgiLimiterProxyTest , self ) . setUp ( )", "self . app = limits . WsgiLimiter ( TEST _ LIMITS )", "self . oldHTTPConnection = (", "wire _ HTTPConnection _ to _ WSGI ( `` 169 . 254 . 0 . 1 : 80 `` , self . app ) )", "self . proxy = limits . WsgiLimiterProxy ( `` 169 . 254 . 0 . 1 : 80 `` )", "def test _ 200 ( self ) :", "`` `` `` Successful request test . `` `` ``", "delay = self . proxy . check _ for _ delay ( `` GET `` , `` / anything `` )", "self . assertEqual ( delay , ( None , None ) )", "def test _ 403 ( self ) :", "`` `` `` Forbidden request test . `` `` ``", "delay = self . proxy . check _ for _ delay ( `` GET `` , `` / delayed `` )", "self . assertEqual ( delay , ( None , None ) )", "delay , error = self . proxy . check _ for _ delay ( `` GET `` , `` / delayed `` )", "error = error . strip ( )", "expected = ( `` 60 . 00 `` , `` 403 Forbidden \ n \ nOnly 1 GET request ( s ) can be ``", "`` made to / delayed every minute . `` )", "self . assertEqual ( ( delay , error ) , expected )", "def tearDown ( self ) :", "# restore original HTTPConnection object", "httplib . HTTPConnection = self . oldHTTPConnection", "class LimitsViewBuilderTest ( test . TestCase ) :", "def setUp ( self ) :", "super ( LimitsViewBuilderTest , self ) . setUp ( )", "self . view _ builder = views . limits . ViewBuilder ( )", "self . rate _ limits = [ { `` URI `` : `` * `` ,", "`` regex `` : `` . * `` ,", "`` value `` : 10 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 2 ,", "`` unit `` : `` MINUTE `` ,", "`` resetTime `` : 1311272226 } ,", "{ `` URI `` : `` * / volumes `` ,", "`` regex `` : `` ^ / volumes `` ,", "`` value `` : 50 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 10 ,", "`` unit `` : `` DAY `` ,", "`` resetTime `` : 1311272226 } ]", "self . absolute _ limits = { `` metadata _ items `` : 1 ,", "`` injected _ files `` : 5 ,", "`` injected _ file _ content _ bytes `` : 5 }", "def test _ build _ limits ( self ) :", "expected _ limits = {", "`` limits `` : {", "`` rate `` : [", "{", "`` uri `` : `` * `` ,", "`` regex `` : `` . * `` ,", "`` limit `` : [", "{", "`` value `` : 10 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 2 ,", "`` unit `` : `` MINUTE `` ,", "`` next - available `` : `` 2011 - 07 - 21T18 : 17 : 06Z ``", "}", "]", "} ,", "{", "`` uri `` : `` * / volumes `` ,", "`` regex `` : `` ^ / volumes `` ,", "`` limit `` : [", "{", "`` value `` : 50 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 10 ,", "`` unit `` : `` DAY `` ,", "`` next - available `` : `` 2011 - 07 - 21T18 : 17 : 06Z ``", "}", "]", "}", "] ,", "`` absolute `` : {", "`` maxServerMeta `` : 1 ,", "`` maxImageMeta `` : 1 ,", "`` maxPersonality `` : 5 ,", "`` maxPersonalitySize `` : 5", "}", "}", "}", "output = self . view _ builder . build ( self . rate _ limits ,", "self . absolute _ limits )", "self . assertDictMatch ( output , expected _ limits )", "def test _ build _ limits _ empty _ limits ( self ) :", "expected _ limits = { `` limits `` : { `` rate `` : [ ] ,", "`` absolute `` : { } } }", "abs _ limits = { }", "rate _ limits = [ ]", "output = self . view _ builder . build ( rate _ limits , abs _ limits )", "self . assertDictMatch ( output , expected _ limits )", "class LimitsXMLSerializationTest ( test . TestCase ) :", "def test _ xml _ declaration ( self ) :", "serializer = limits . LimitsTemplate ( )", "fixture = { `` limits `` : {", "`` rate `` : [ ] ,", "`` absolute `` : { } } }", "output = serializer . serialize ( fixture )", "has _ dec = output . startswith ( `` < ? xml version = ' 1 . 0 ' encoding = ' UTF - 8 ' ? > `` )", "self . assertTrue ( has _ dec )", "def test _ index ( self ) :", "serializer = limits . LimitsTemplate ( )", "fixture = {", "`` limits `` : {", "`` rate `` : [ {", "`` uri `` : `` * `` ,", "`` regex `` : `` . * `` ,", "`` limit `` : [ {", "`` value `` : 10 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 2 ,", "`` unit `` : `` MINUTE `` ,", "`` next - available `` : `` 2011 - 12 - 15T22 : 42 : 45Z `` } ] } ,", "{ `` uri `` : `` * / servers `` ,", "`` regex `` : `` ^ / servers `` ,", "`` limit `` : [ {", "`` value `` : 50 ,", "`` verb `` : `` POST `` ,", "`` remaining `` : 10 ,", "`` unit `` : `` DAY `` ,", "`` next - available `` : `` 2011 - 12 - 15T22 : 42 : 45Z `` } ] } ] ,", "`` absolute `` : { `` maxServerMeta `` : 1 ,", "`` maxImageMeta `` : 1 ,", "`` maxPersonality `` : 5 ,", "`` maxPersonalitySize `` : 10240 } } }", "output = serializer . serialize ( fixture )", "root = etree . XML ( output )", "xmlutil . validate _ schema ( root , ' limits ' )", "# verify absolute limits", "absolutes = root . xpath ( ' ns : absolute / ns : limit ' , namespaces = NS )", "self . assertEqual ( len ( absolutes ) , 4 )", "for limit in absolutes :", "name = limit . get ( ' name ' )", "value = limit . get ( ' value ' )", "self . assertEqual ( value , str ( fixture [ ' limits ' ] [ ' absolute ' ] [ name ] ) )", "# verify rate limits", "rates = root . xpath ( ' ns : rates / ns : rate ' , namespaces = NS )", "self . assertEqual ( len ( rates ) , 2 )", "for i , rate in enumerate ( rates ) :", "for key in [ ' uri ' , ' regex ' ] :", "self . assertEqual ( rate . get ( key ) ,", "str ( fixture [ ' limits ' ] [ ' rate ' ] [ i ] [ key ] ) )", "rate _ limits = rate . xpath ( ' ns : limit ' , namespaces = NS )", "self . assertEqual ( len ( rate _ limits ) , 1 )", "for j , limit in enumerate ( rate _ limits ) :", "for key in [ ' verb ' , ' value ' , ' remaining ' , ' unit ' ,", "' next - available ' ] :", "self . assertEqual ( limit . get ( key ) ,", "str ( fixture [ ' limits ' ] [ ' rate ' ] [ i ] [ ' limit ' ] [ j ] [ key ] ) )", "def test _ index _ no _ limits ( self ) :", "serializer = limits . LimitsTemplate ( )", "fixture = { `` limits `` : {", "`` rate `` : [ ] ,", "`` absolute `` : { } } }", "output = serializer . serialize ( fixture )", "root = etree . XML ( output )", "xmlutil . validate _ schema ( root , ' limits ' )", "# verify absolute limits", "absolutes = root . xpath ( ' ns : absolute / ns : limit ' , namespaces = NS )", "self . assertEqual ( len ( absolutes ) , 0 )", "# verify rate limits", "rates = root . xpath ( ' ns : rates / ns : rate ' , namespaces = NS )", "self . assertEqual ( len ( rates ) , 0 )", ],"removed_code":[]},{"added_code":["Copyright 2011 Denali Systems , Inc .", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "import datetime", "from lxml import etree", "import webob", "from cinder . api . v2 import snapshots", "from cinder import db", "from cinder import exception", "from cinder import flags", "from cinder . openstack . common import log as logging", "from cinder import test", "from cinder . tests . api . openstack import fakes", "from cinder import volume", "FLAGS = flags . FLAGS", "LOG = logging . getLogger ( _ _ name _ _ )", "UUID = ' 00000000 - 0000 - 0000 - 0000 - 000000000001 '", "INVALID _ UUID = ' 00000000 - 0000 - 0000 - 0000 - 000000000002 '", "def _ get _ default _ snapshot _ param ( ) :", "return {", "' id ' : UUID ,", "' volume _ id ' : 12 ,", "' status ' : ' available ' ,", "' volume _ size ' : 100 ,", "' created _ at ' : None ,", "' display _ name ' : ' Default name ' ,", "' display _ description ' : ' Default description ' ,", "}", "def stub _ snapshot _ create ( self , context , volume _ id , name , description ) :", "snapshot = _ get _ default _ snapshot _ param ( )", "snapshot [ ' volume _ id ' ] = volume _ id", "snapshot [ ' display _ name ' ] = name", "snapshot [ ' display _ description ' ] = description", "return snapshot", "def stub _ snapshot _ delete ( self , context , snapshot ) :", "if snapshot [ ' id ' ] ! = UUID :", "raise exception . NotFound", "def stub _ snapshot _ get ( self , context , snapshot _ id ) :", "if snapshot _ id ! = UUID :", "raise exception . NotFound", "param = _ get _ default _ snapshot _ param ( )", "return param", "def stub _ snapshot _ get _ all ( self , context , search _ opts = None ) :", "param = _ get _ default _ snapshot _ param ( )", "return [ param ]", "class SnapshotApiTest ( test . TestCase ) :", "def setUp ( self ) :", "super ( SnapshotApiTest , self ) . setUp ( )", "self . controller = snapshots . SnapshotsController ( )", "self . stubs . Set ( db , ' snapshot _ get _ all _ by _ project ' ,", "fakes . stub _ snapshot _ get _ all _ by _ project )", "self . stubs . Set ( db , ' snapshot _ get _ all ' ,", "fakes . stub _ snapshot _ get _ all )", "def test _ snapshot _ create ( self ) :", "self . stubs . Set ( volume . api . API , `` create _ snapshot `` , stub _ snapshot _ create )", "self . stubs . Set ( volume . api . API , ' get ' , fakes . stub _ volume _ get )", "snapshot = {", "`` volume _ id `` : ' 12 ' ,", "`` force `` : False ,", "`` display _ name `` : `` Snapshot Test Name `` ,", "`` display _ description `` : `` Snapshot Test Desc ``", "}", "body = dict ( snapshot = snapshot )", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ' )", "resp _ dict = self . controller . create ( req , body )", "self . assertTrue ( ' snapshot ' in resp _ dict )", "self . assertEqual ( resp _ dict [ ' snapshot ' ] [ ' display _ name ' ] ,", "snapshot [ ' display _ name ' ] )", "self . assertEqual ( resp _ dict [ ' snapshot ' ] [ ' display _ description ' ] ,", "snapshot [ ' display _ description ' ] )", "def test _ snapshot _ create _ force ( self ) :", "self . stubs . Set ( volume . api . API , `` create _ snapshot _ force `` ,", "stub _ snapshot _ create )", "self . stubs . Set ( volume . api . API , ' get ' , fakes . stub _ volume _ get )", "snapshot = {", "`` volume _ id `` : ' 12 ' ,", "`` force `` : True ,", "`` display _ name `` : `` Snapshot Test Name `` ,", "`` display _ description `` : `` Snapshot Test Desc ``", "}", "body = dict ( snapshot = snapshot )", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ' )", "resp _ dict = self . controller . create ( req , body )", "self . assertTrue ( ' snapshot ' in resp _ dict )", "self . assertEqual ( resp _ dict [ ' snapshot ' ] [ ' display _ name ' ] ,", "snapshot [ ' display _ name ' ] )", "self . assertEqual ( resp _ dict [ ' snapshot ' ] [ ' display _ description ' ] ,", "snapshot [ ' display _ description ' ] )", "snapshot = {", "`` volume _ id `` : `` 12 `` ,", "`` force `` : `` * * & & ^ ^ % % $ $ # # @ @ `` ,", "`` display _ name `` : `` Snapshot Test Name `` ,", "`` display _ description `` : `` Snapshot Test Desc ``", "}", "body = dict ( snapshot = snapshot )", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ' )", "self . assertRaises ( exception . InvalidParameterValue ,", "self . controller . create ,", "req ,", "body )", "def test _ snapshot _ update ( self ) :", "self . stubs . Set ( volume . api . API , `` get _ snapshot `` , stub _ snapshot _ get )", "self . stubs . Set ( volume . api . API , `` update _ snapshot `` ,", "fakes . stub _ snapshot _ update )", "updates = {", "`` display _ name `` : `` Updated Test Name `` ,", "}", "body = { `` snapshot `` : updates }", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % UUID )", "res _ dict = self . controller . update ( req , UUID , body )", "expected = {", "' snapshot ' : {", "' id ' : UUID ,", "' volume _ id ' : 12 ,", "' status ' : ' available ' ,", "' size ' : 100 ,", "' created _ at ' : None ,", "' display _ name ' : ' Updated Test Name ' ,", "' display _ description ' : ' Default description ' ,", "}", "}", "self . assertEquals ( expected , res _ dict )", "def test _ snapshot _ update _ missing _ body ( self ) :", "body = { }", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % UUID )", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . update , req , UUID , body )", "def test _ snapshot _ update _ invalid _ body ( self ) :", "body = { ' display _ name ' : ' missing top level snapshot key ' }", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % UUID )", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . update , req , UUID , body )", "def test _ snapshot _ update _ not _ found ( self ) :", "self . stubs . Set ( volume . api . API , `` get _ snapshot `` , stub _ snapshot _ get )", "updates = {", "`` display _ name `` : `` Updated Test Name `` ,", "}", "body = { `` snapshot `` : updates }", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / not - the - uuid ' )", "self . assertRaises ( webob . exc . HTTPNotFound , self . controller . update , req ,", "' not - the - uuid ' , body )", "def test _ snapshot _ delete ( self ) :", "self . stubs . Set ( volume . api . API , `` get _ snapshot `` , stub _ snapshot _ get )", "self . stubs . Set ( volume . api . API , `` delete _ snapshot `` , stub _ snapshot _ delete )", "snapshot _ id = UUID", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % snapshot _ id )", "resp = self . controller . delete ( req , snapshot _ id )", "self . assertEqual ( resp . status _ int , 202 )", "def test _ snapshot _ delete _ invalid _ id ( self ) :", "self . stubs . Set ( volume . api . API , `` delete _ snapshot `` , stub _ snapshot _ delete )", "snapshot _ id = INVALID _ UUID", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % snapshot _ id )", "self . assertRaises ( webob . exc . HTTPNotFound , self . controller . delete ,", "req , snapshot _ id )", "def test _ snapshot _ show ( self ) :", "self . stubs . Set ( volume . api . API , `` get _ snapshot `` , stub _ snapshot _ get )", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % UUID )", "resp _ dict = self . controller . show ( req , UUID )", "self . assertTrue ( ' snapshot ' in resp _ dict )", "self . assertEqual ( resp _ dict [ ' snapshot ' ] [ ' id ' ] , UUID )", "def test _ snapshot _ show _ invalid _ id ( self ) :", "snapshot _ id = INVALID _ UUID", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / % s ' % snapshot _ id )", "self . assertRaises ( webob . exc . HTTPNotFound ,", "self . controller . show , req , snapshot _ id )", "def test _ snapshot _ detail ( self ) :", "self . stubs . Set ( volume . api . API , `` get _ all _ snapshots `` ,", "stub _ snapshot _ get _ all )", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots / detail ' )", "resp _ dict = self . controller . detail ( req )", "self . assertTrue ( ' snapshots ' in resp _ dict )", "resp _ snapshots = resp _ dict [ ' snapshots ' ]", "self . assertEqual ( len ( resp _ snapshots ) , 1 )", "resp _ snapshot = resp _ snapshots . pop ( )", "self . assertEqual ( resp _ snapshot [ ' id ' ] , UUID )", "def test _ snapshot _ list _ by _ status ( self ) :", "def stub _ snapshot _ get _ all _ by _ project ( context , project _ id ) :", "return [", "fakes . stub _ snapshot ( 1 , display _ name = ' backup1 ' ,", "status = ' available ' ) ,", "fakes . stub _ snapshot ( 2 , display _ name = ' backup2 ' ,", "status = ' available ' ) ,", "fakes . stub _ snapshot ( 3 , display _ name = ' backup3 ' ,", "status = ' creating ' ) ,", "]", "self . stubs . Set ( db , ' snapshot _ get _ all _ by _ project ' ,", "stub _ snapshot _ get _ all _ by _ project )", "# no status filter", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 3 )", "# single match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? status = creating ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 1 )", "self . assertEqual ( resp [ ' snapshots ' ] [ 0 ] [ ' status ' ] , ' creating ' )", "# multiple match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? status = available ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 2 )", "for snapshot in resp [ ' snapshots ' ] :", "self . assertEquals ( snapshot [ ' status ' ] , ' available ' )", "# no match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? status = error ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 0 )", "def test _ snapshot _ list _ by _ volume ( self ) :", "def stub _ snapshot _ get _ all _ by _ project ( context , project _ id ) :", "return [", "fakes . stub _ snapshot ( 1 , volume _ id = ' vol1 ' , status = ' creating ' ) ,", "fakes . stub _ snapshot ( 2 , volume _ id = ' vol1 ' , status = ' available ' ) ,", "fakes . stub _ snapshot ( 3 , volume _ id = ' vol2 ' , status = ' available ' ) ,", "]", "self . stubs . Set ( db , ' snapshot _ get _ all _ by _ project ' ,", "stub _ snapshot _ get _ all _ by _ project )", "# single match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? volume _ id = vol2 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 1 )", "self . assertEqual ( resp [ ' snapshots ' ] [ 0 ] [ ' volume _ id ' ] , ' vol2 ' )", "# multiple match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? volume _ id = vol1 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 2 )", "for snapshot in resp [ ' snapshots ' ] :", "self . assertEqual ( snapshot [ ' volume _ id ' ] , ' vol1 ' )", "# multiple filters", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? volume _ id = vol1 '", "' & status = available ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 1 )", "self . assertEqual ( resp [ ' snapshots ' ] [ 0 ] [ ' volume _ id ' ] , ' vol1 ' )", "self . assertEqual ( resp [ ' snapshots ' ] [ 0 ] [ ' status ' ] , ' available ' )", "def test _ snapshot _ list _ by _ name ( self ) :", "def stub _ snapshot _ get _ all _ by _ project ( context , project _ id ) :", "return [", "fakes . stub _ snapshot ( 1 , display _ name = ' backup1 ' ) ,", "fakes . stub _ snapshot ( 2 , display _ name = ' backup2 ' ) ,", "fakes . stub _ snapshot ( 3 , display _ name = ' backup3 ' ) ,", "]", "self . stubs . Set ( db , ' snapshot _ get _ all _ by _ project ' ,", "stub _ snapshot _ get _ all _ by _ project )", "# no display _ name filter", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 3 )", "# filter by one name", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? display _ name = backup2 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 1 )", "self . assertEquals ( resp [ ' snapshots ' ] [ 0 ] [ ' display _ name ' ] , ' backup2 ' )", "# filter no match", "req = fakes . HTTPRequest . blank ( ' / v2 / snapshots ? display _ name = backup4 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' snapshots ' ] ) , 0 )", "def test _ admin _ list _ snapshots _ limited _ to _ project ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / snapshots ' ,", "use _ admin _ context = True )", "res = self . controller . index ( req )", "self . assertTrue ( ' snapshots ' in res )", "self . assertEqual ( 1 , len ( res [ ' snapshots ' ] ) )", "def test _ admin _ list _ snapshots _ all _ tenants ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / snapshots ? all _ tenants = 1 ' ,", "use _ admin _ context = True )", "res = self . controller . index ( req )", "self . assertTrue ( ' snapshots ' in res )", "self . assertEqual ( 3 , len ( res [ ' snapshots ' ] ) )", "def test _ all _ tenants _ non _ admin _ gets _ all _ tenants ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / snapshots ? all _ tenants = 1 ' )", "res = self . controller . index ( req )", "self . assertTrue ( ' snapshots ' in res )", "self . assertEqual ( 1 , len ( res [ ' snapshots ' ] ) )", "def test _ non _ admin _ get _ by _ project ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / snapshots ' )", "res = self . controller . index ( req )", "self . assertTrue ( ' snapshots ' in res )", "self . assertEqual ( 1 , len ( res [ ' snapshots ' ] ) )", "class SnapshotSerializerTest ( test . TestCase ) :", "def _ verify _ snapshot ( self , snap , tree ) :", "self . assertEqual ( tree . tag , ' snapshot ' )", "for attr in ( ' id ' , ' status ' , ' size ' , ' created _ at ' ,", "' display _ name ' , ' display _ description ' , ' volume _ id ' ) :", "self . assertEqual ( str ( snap [ attr ] ) , tree . get ( attr ) )", "def test _ snapshot _ show _ create _ serializer ( self ) :", "serializer = snapshots . SnapshotTemplate ( )", "raw _ snapshot = dict (", "id = ' snap _ id ' ,", "status = ' snap _ status ' ,", "size = 1024 ,", "created _ at = datetime . datetime . now ( ) ,", "display _ name = ' snap _ name ' ,", "display _ description = ' snap _ desc ' ,", "volume _ id = ' vol _ id ' ,", ")", "text = serializer . serialize ( dict ( snapshot = raw _ snapshot ) )", "print text", "tree = etree . fromstring ( text )", "self . _ verify _ snapshot ( raw _ snapshot , tree )", "def test _ snapshot _ index _ detail _ serializer ( self ) :", "serializer = snapshots . SnapshotsTemplate ( )", "raw _ snapshots = [", "dict (", "id = ' snap1 _ id ' ,", "status = ' snap1 _ status ' ,", "size = 1024 ,", "created _ at = datetime . datetime . now ( ) ,", "display _ name = ' snap1 _ name ' ,", "display _ description = ' snap1 _ desc ' ,", "volume _ id = ' vol1 _ id ' ,", ") ,", "dict (", "id = ' snap2 _ id ' ,", "status = ' snap2 _ status ' ,", "size = 1024 ,", "created _ at = datetime . datetime . now ( ) ,", "display _ name = ' snap2 _ name ' ,", "display _ description = ' snap2 _ desc ' ,", "volume _ id = ' vol2 _ id ' ,", ")", "]", "text = serializer . serialize ( dict ( snapshots = raw _ snapshots ) )", "print text", "tree = etree . fromstring ( text )", "self . assertEqual ( ' snapshots ' , tree . tag )", "self . assertEqual ( len ( raw _ snapshots ) , len ( tree ) )", "for idx , child in enumerate ( tree ) :", "self . _ verify _ snapshot ( raw _ snapshots [ idx ] , child )", "class SnapshotsUnprocessableEntityTestCase ( test . TestCase ) :", "`` `` ``", "Tests of places we throw 422 Unprocessable Entity from", "`` `` ``", "def setUp ( self ) :", "super ( SnapshotsUnprocessableEntityTestCase , self ) . setUp ( )", "self . controller = snapshots . SnapshotsController ( )", "def _ unprocessable _ snapshot _ create ( self , body ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / snapshots ' )", "req . method = ' POST '", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . create , req , body )", "def test _ create _ no _ body ( self ) :", "self . _ unprocessable _ snapshot _ create ( body = None )", "def test _ create _ missing _ snapshot ( self ) :", "body = { ' foo ' : { ' a ' : ' b ' } }", "self . _ unprocessable _ snapshot _ create ( body = body )", "def test _ create _ malformed _ entity ( self ) :", "body = { ' snapshot ' : ' string ' }", "self . _ unprocessable _ snapshot _ create ( body = body )", ],"removed_code":[]},{"added_code":["Copyright 2011 OpenStack LLC .", "aLL Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "from lxml import etree", "import webob", "from cinder . api . v2 import types", "from cinder . api . views import types as views _ types", "from cinder import exception", "from cinder . openstack . common import timeutils", "from cinder import test", "from cinder . tests . api . openstack import fakes", "from cinder . volume import volume _ types", "def stub _ volume _ type ( id ) :", "specs = {", "`` key1 `` : `` value1 `` ,", "`` key2 `` : `` value2 `` ,", "`` key3 `` : `` value3 `` ,", "`` key4 `` : `` value4 `` ,", "`` key5 `` : `` value5 ``", "}", "return dict (", "id = id ,", "name = ' vol _ type _ % s ' % str ( id ) ,", "extra _ specs = specs ,", ")", "def return _ volume _ types _ get _ all _ types ( context ) :", "return dict (", "vol _ type _ 1 = stub _ volume _ type ( 1 ) ,", "vol _ type _ 2 = stub _ volume _ type ( 2 ) ,", "vol _ type _ 3 = stub _ volume _ type ( 3 )", ")", "def return _ empty _ volume _ types _ get _ all _ types ( context ) :", "return { }", "def return _ volume _ types _ get _ volume _ type ( context , id ) :", "if id = = `` 777 `` :", "raise exception . VolumeTypeNotFound ( volume _ type _ id = id )", "return stub _ volume _ type ( int ( id ) )", "def return _ volume _ types _ get _ by _ name ( context , name ) :", "if name = = `` 777 `` :", "raise exception . VolumeTypeNotFoundByName ( volume _ type _ name = name )", "return stub _ volume _ type ( int ( name . split ( `` _ `` ) [ 2 ] ) )", "class VolumeTypesApiTest ( test . TestCase ) :", "def setUp ( self ) :", "super ( VolumeTypesApiTest , self ) . setUp ( )", "self . controller = types . VolumeTypesController ( )", "def test _ volume _ types _ index ( self ) :", "self . stubs . Set ( volume _ types , ' get _ all _ types ' ,", "return _ volume _ types _ get _ all _ types )", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / types ' )", "res _ dict = self . controller . index ( req )", "self . assertEqual ( 3 , len ( res _ dict [ ' volume _ types ' ] ) )", "expected _ names = [ ' vol _ type _ 1 ' , ' vol _ type _ 2 ' , ' vol _ type _ 3 ' ]", "actual _ names = map ( lambda e : e [ ' name ' ] , res _ dict [ ' volume _ types ' ] )", "self . assertEqual ( set ( actual _ names ) , set ( expected _ names ) )", "for entry in res _ dict [ ' volume _ types ' ] :", "self . assertEqual ( ' value1 ' , entry [ ' extra _ specs ' ] [ ' key1 ' ] )", "def test _ volume _ types _ index _ no _ data ( self ) :", "self . stubs . Set ( volume _ types , ' get _ all _ types ' ,", "return _ empty _ volume _ types _ get _ all _ types )", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / types ' )", "res _ dict = self . controller . index ( req )", "self . assertEqual ( 0 , len ( res _ dict [ ' volume _ types ' ] ) )", "def test _ volume _ types _ show ( self ) :", "self . stubs . Set ( volume _ types , ' get _ volume _ type ' ,", "return _ volume _ types _ get _ volume _ type )", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / types / 1 ' )", "res _ dict = self . controller . show ( req , 1 )", "self . assertEqual ( 1 , len ( res _ dict ) )", "self . assertEqual ( ' 1 ' , res _ dict [ ' volume _ type ' ] [ ' id ' ] )", "self . assertEqual ( ' vol _ type _ 1 ' , res _ dict [ ' volume _ type ' ] [ ' name ' ] )", "def test _ volume _ types _ show _ not _ found ( self ) :", "self . stubs . Set ( volume _ types , ' get _ volume _ type ' ,", "return _ volume _ types _ get _ volume _ type )", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / types / 777 ' )", "self . assertRaises ( webob . exc . HTTPNotFound , self . controller . show ,", "req , ' 777 ' )", "def test _ view _ builder _ show ( self ) :", "view _ builder = views _ types . ViewBuilder ( )", "now = timeutils . isotime ( )", "raw _ volume _ type = dict (", "name = ' new _ type ' ,", "deleted = False ,", "created _ at = now ,", "updated _ at = now ,", "extra _ specs = { } ,", "deleted _ at = None ,", "id = 42 ,", ")", "request = fakes . HTTPRequest . blank ( `` / v2 `` )", "output = view _ builder . show ( request , raw _ volume _ type )", "self . assertTrue ( ' volume _ type ' in output )", "expected _ volume _ type = dict (", "name = ' new _ type ' ,", "extra _ specs = { } ,", "id = 42 ,", ")", "self . assertDictMatch ( output [ ' volume _ type ' ] , expected _ volume _ type )", "def test _ view _ builder _ list ( self ) :", "view _ builder = views _ types . ViewBuilder ( )", "now = timeutils . isotime ( )", "raw _ volume _ types = [ ]", "for i in range ( 0 , 10 ) :", "raw _ volume _ types . append (", "dict (", "name = ' new _ type ' ,", "deleted = False ,", "created _ at = now ,", "updated _ at = now ,", "extra _ specs = { } ,", "deleted _ at = None ,", "id = 42 + i", ")", ")", "request = fakes . HTTPRequest . blank ( `` / v2 `` )", "output = view _ builder . index ( request , raw _ volume _ types )", "self . assertTrue ( ' volume _ types ' in output )", "for i in range ( 0 , 10 ) :", "expected _ volume _ type = dict (", "name = ' new _ type ' ,", "extra _ specs = { } ,", "id = 42 + i", ")", "self . assertDictMatch ( output [ ' volume _ types ' ] [ i ] ,", "expected _ volume _ type )", "class VolumeTypesSerializerTest ( test . TestCase ) :", "def _ verify _ volume _ type ( self , vtype , tree ) :", "self . assertEqual ( ' volume _ type ' , tree . tag )", "self . assertEqual ( vtype [ ' name ' ] , tree . get ( ' name ' ) )", "self . assertEqual ( str ( vtype [ ' id ' ] ) , tree . get ( ' id ' ) )", "self . assertEqual ( 1 , len ( tree ) )", "extra _ specs = tree [ 0 ]", "self . assertEqual ( ' extra _ specs ' , extra _ specs . tag )", "seen = set ( vtype [ ' extra _ specs ' ] . keys ( ) )", "for child in extra _ specs :", "self . assertTrue ( child . tag in seen )", "self . assertEqual ( vtype [ ' extra _ specs ' ] [ child . tag ] , child . text )", "seen . remove ( child . tag )", "self . assertEqual ( len ( seen ) , 0 )", "def test _ index _ serializer ( self ) :", "serializer = types . VolumeTypesTemplate ( )", "# Just getting some input data", "vtypes = return _ volume _ types _ get _ all _ types ( None )", "text = serializer . serialize ( { ' volume _ types ' : vtypes . values ( ) } )", "tree = etree . fromstring ( text )", "self . assertEqual ( ' volume _ types ' , tree . tag )", "self . assertEqual ( len ( vtypes ) , len ( tree ) )", "for child in tree :", "name = child . get ( ' name ' )", "self . assertTrue ( name in vtypes )", "self . _ verify _ volume _ type ( vtypes [ name ] , child )", "def test _ voltype _ serializer ( self ) :", "serializer = types . VolumeTypeTemplate ( )", "vtype = stub _ volume _ type ( 1 )", "text = serializer . serialize ( dict ( volume _ type = vtype ) )", "tree = etree . fromstring ( text )", "self . _ verify _ volume _ type ( vtype , tree )", ],"removed_code":[]},{"added_code":["Copyright 2013 Josh Durgin", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "import datetime", "from lxml import etree", "import webob", "from cinder . api import extensions", "from cinder . api . v2 import volumes", "from cinder import context", "from cinder import db", "from cinder import exception", "from cinder import flags", "from cinder import test", "from cinder . tests . api . openstack import fakes", "from cinder . tests . image import fake as fake _ image", "from cinder . volume import api as volume _ api", "FLAGS = flags . FLAGS", "NS = ' { http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content } '", "TEST _ SNAPSHOT _ UUID = ' 00000000 - 0000 - 0000 - 0000 - 000000000001 '", "def stub _ snapshot _ get ( self , context , snapshot _ id ) :", "if snapshot _ id ! = TEST _ SNAPSHOT _ UUID :", "raise exception . NotFound", "return {", "' id ' : snapshot _ id ,", "' volume _ id ' : 12 ,", "' status ' : ' available ' ,", "' volume _ size ' : 100 ,", "' created _ at ' : None ,", "' display _ name ' : ' Default name ' ,", "' display _ description ' : ' Default description ' ,", "}", "class VolumeApiTest ( test . TestCase ) :", "def setUp ( self ) :", "super ( VolumeApiTest , self ) . setUp ( )", "self . ext _ mgr = extensions . ExtensionManager ( )", "self . ext _ mgr . extensions = { }", "fake _ image . stub _ out _ image _ service ( self . stubs )", "self . controller = volumes . VolumeController ( self . ext _ mgr )", "self . stubs . Set ( db , ' volume _ get _ all ' , fakes . stub _ volume _ get _ all )", "self . stubs . Set ( db , ' volume _ get _ all _ by _ project ' ,", "fakes . stub _ volume _ get _ all _ by _ project )", "self . stubs . Set ( volume _ api . API , ' get ' , fakes . stub _ volume _ get )", "self . stubs . Set ( volume _ api . API , ' delete ' , fakes . stub _ volume _ delete )", "def test _ volume _ create ( self ) :", "self . stubs . Set ( volume _ api . API , `` create `` , fakes . stub _ volume _ create )", "vol = {", "`` size `` : 100 ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` zone1 : host1 ``", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "res _ dict = self . controller . create ( req , body )", "expected = {", "' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' Volume Test Desc ' ,", "' availability _ zone ' : ' zone1 : host1 ' ,", "' display _ name ' : ' Volume Test Name ' ,", "' attachments ' : [", "{", "' device ' : ' / ' ,", "' server _ id ' : ' fakeuuid ' ,", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 '", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 100", "}", "}", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ create _ with _ type ( self ) :", "vol _ type = FLAGS . default _ volume _ type", "db . volume _ type _ create ( context . get _ admin _ context ( ) ,", "dict ( name = vol _ type , extra _ specs = { } ) )", "db _ vol _ type = db . volume _ type _ get _ by _ name ( context . get _ admin _ context ( ) ,", "vol _ type )", "vol = {", "`` size `` : 100 ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` zone1 : host1 `` ,", "`` volume _ type `` : db _ vol _ type [ ' name ' ] ,", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "res _ dict = self . controller . create ( req , body )", "self . assertEquals ( res _ dict [ ' volume ' ] [ ' volume _ type ' ] ,", "db _ vol _ type [ ' name ' ] )", "def test _ volume _ creation _ fails _ with _ bad _ size ( self ) :", "vol = { `` size `` : ' ' ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` zone1 : host1 `` }", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "self . assertRaises ( exception . InvalidInput ,", "self . controller . create ,", "req ,", "body )", "def test _ volume _ create _ with _ image _ id ( self ) :", "self . stubs . Set ( volume _ api . API , `` create `` , fakes . stub _ volume _ create )", "self . ext _ mgr . extensions = { ' os - image - create ' : ' fake ' }", "vol = { `` size `` : ' 1 ' ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` nova `` ,", "`` imageRef `` : ' c905cedb - 7281 - 47e4 - 8a62 - f26bc5fc4c77 ' }", "expected = {", "' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' Volume Test Desc ' ,", "' availability _ zone ' : ' nova ' ,", "' display _ name ' : ' Volume Test Name ' ,", "' attachments ' : [", "{", "' device ' : ' / ' ,", "' server _ id ' : ' fakeuuid ' ,", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 '", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' image _ id ' : ' c905cedb - 7281 - 47e4 - 8a62 - f26bc5fc4c77 ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : ' 1 ' }", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "res _ dict = self . controller . create ( req , body )", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ create _ with _ image _ id _ and _ snapshot _ id ( self ) :", "self . stubs . Set ( volume _ api . API , `` create `` , fakes . stub _ volume _ create )", "self . stubs . Set ( volume _ api . API , `` get _ snapshot `` , stub _ snapshot _ get )", "self . ext _ mgr . extensions = { ' os - image - create ' : ' fake ' }", "vol = {", "`` size `` : ' 1 ' ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` cinder `` ,", "`` imageRef `` : ' c905cedb - 7281 - 47e4 - 8a62 - f26bc5fc4c77 ' ,", "`` snapshot _ id `` : TEST _ SNAPSHOT _ UUID", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "self . assertRaises ( webob . exc . HTTPBadRequest ,", "self . controller . create ,", "req ,", "body )", "def test _ volume _ create _ with _ image _ id _ is _ integer ( self ) :", "self . stubs . Set ( volume _ api . API , `` create `` , fakes . stub _ volume _ create )", "self . ext _ mgr . extensions = { ' os - image - create ' : ' fake ' }", "vol = {", "`` size `` : ' 1 ' ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` cinder `` ,", "`` imageRef `` : 1234 ,", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "self . assertRaises ( webob . exc . HTTPBadRequest ,", "self . controller . create ,", "req ,", "body )", "def test _ volume _ create _ with _ image _ id _ not _ uuid _ format ( self ) :", "self . stubs . Set ( volume _ api . API , `` create `` , fakes . stub _ volume _ create )", "self . ext _ mgr . extensions = { ' os - image - create ' : ' fake ' }", "vol = {", "`` size `` : ' 1 ' ,", "`` display _ name `` : `` Volume Test Name `` ,", "`` display _ description `` : `` Volume Test Desc `` ,", "`` availability _ zone `` : `` cinder `` ,", "`` imageRef `` : ' 12345 '", "}", "body = { `` volume `` : vol }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "self . assertRaises ( webob . exc . HTTPBadRequest ,", "self . controller . create ,", "req ,", "body )", "def test _ volume _ update ( self ) :", "self . stubs . Set ( volume _ api . API , `` update `` , fakes . stub _ volume _ update )", "updates = {", "`` display _ name `` : `` Updated Test Name `` ,", "}", "body = { `` volume `` : updates }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "res _ dict = self . controller . update ( req , ' 1 ' , body )", "expected = {", "' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' Updated Test Name ' ,", "' attachments ' : [", "{", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 ' ,", "' server _ id ' : ' fakeuuid ' ,", "' device ' : ' / ' ,", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1 ,", "}", "}", "self . assertEquals ( res _ dict , expected )", "def test _ volume _ update _ metadata ( self ) :", "self . stubs . Set ( volume _ api . API , `` update `` , fakes . stub _ volume _ update )", "updates = {", "`` metadata `` : { `` qos _ max _ iops `` : 2000 }", "}", "body = { `` volume `` : updates }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "res _ dict = self . controller . update ( req , ' 1 ' , body )", "expected = { ' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' displayname ' ,", "' attachments ' : [ {", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 ' ,", "' server _ id ' : ' fakeuuid ' ,", "' device ' : ' / ' ,", "} ] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { `` qos _ max _ iops `` : 2000 } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1 ,", "} }", "self . assertEquals ( res _ dict , expected )", "def test _ update _ empty _ body ( self ) :", "body = { }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . update ,", "req , ' 1 ' , body )", "def test _ update _ invalid _ body ( self ) :", "body = {", "' display _ name ' : ' missing top level volume key '", "}", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . update ,", "req , ' 1 ' , body )", "def test _ update _ not _ found ( self ) :", "self . stubs . Set ( volume _ api . API , `` get `` , fakes . stub _ volume _ get _ notfound )", "updates = {", "`` display _ name `` : `` Updated Test Name `` ,", "}", "body = { `` volume `` : updates }", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "self . assertRaises ( webob . exc . HTTPNotFound ,", "self . controller . update ,", "req , ' 1 ' , body )", "def test _ volume _ list ( self ) :", "self . stubs . Set ( volume _ api . API , ' get _ all ' ,", "fakes . stub _ volume _ get _ all _ by _ project )", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "res _ dict = self . controller . index ( req )", "expected = {", "' volumes ' : [", "{", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' displayname ' ,", "' attachments ' : [", "{", "' device ' : ' / ' ,", "' server _ id ' : ' fakeuuid ' ,", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 '", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1", "}", "]", "}", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ list _ detail ( self ) :", "self . stubs . Set ( volume _ api . API , ' get _ all ' ,", "fakes . stub _ volume _ get _ all _ by _ project )", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / detail ' )", "res _ dict = self . controller . index ( req )", "expected = {", "' volumes ' : [", "{", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' displayname ' ,", "' attachments ' : [", "{", "' device ' : ' / ' ,", "' server _ id ' : ' fakeuuid ' ,", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 '", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1", "}", "]", "}", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ list _ by _ name ( self ) :", "def stub _ volume _ get _ all _ by _ project ( context , project _ id ) :", "return [", "fakes . stub _ volume ( 1 , display _ name = ' vol1 ' ) ,", "fakes . stub _ volume ( 2 , display _ name = ' vol2 ' ) ,", "fakes . stub _ volume ( 3 , display _ name = ' vol3 ' ) ,", "]", "self . stubs . Set ( db , ' volume _ get _ all _ by _ project ' ,", "stub _ volume _ get _ all _ by _ project )", "# no display _ name filter", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 3 )", "# filter on display _ name", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? display _ name = vol2 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 1 )", "self . assertEqual ( resp [ ' volumes ' ] [ 0 ] [ ' display _ name ' ] , ' vol2 ' )", "# filter no match", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? display _ name = vol4 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 0 )", "def test _ volume _ list _ by _ status ( self ) :", "def stub _ volume _ get _ all _ by _ project ( context , project _ id ) :", "return [", "fakes . stub _ volume ( 1 , display _ name = ' vol1 ' , status = ' available ' ) ,", "fakes . stub _ volume ( 2 , display _ name = ' vol2 ' , status = ' available ' ) ,", "fakes . stub _ volume ( 3 , display _ name = ' vol3 ' , status = ' in - use ' ) ,", "]", "self . stubs . Set ( db , ' volume _ get _ all _ by _ project ' ,", "stub _ volume _ get _ all _ by _ project )", "# no status filter", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 3 )", "# single match", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? status = in - use ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 1 )", "self . assertEqual ( resp [ ' volumes ' ] [ 0 ] [ ' status ' ] , ' in - use ' )", "# multiple match", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? status = available ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 2 )", "for volume in resp [ ' volumes ' ] :", "self . assertEqual ( volume [ ' status ' ] , ' available ' )", "# multiple filters", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? status = available & '", "' display _ name = vol1 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 1 )", "self . assertEqual ( resp [ ' volumes ' ] [ 0 ] [ ' display _ name ' ] , ' vol1 ' )", "self . assertEqual ( resp [ ' volumes ' ] [ 0 ] [ ' status ' ] , ' available ' )", "# no match", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes ? status = in - use & '", "' display _ name = vol1 ' )", "resp = self . controller . index ( req )", "self . assertEqual ( len ( resp [ ' volumes ' ] ) , 0 )", "def test _ volume _ show ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "res _ dict = self . controller . show ( req , ' 1 ' )", "expected = {", "' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' displayname ' ,", "' attachments ' : [", "{", "' device ' : ' / ' ,", "' server _ id ' : ' fakeuuid ' ,", "' id ' : ' 1 ' ,", "' volume _ id ' : ' 1 '", "}", "] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1", "}", "}", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ show _ no _ attachments ( self ) :", "def stub _ volume _ get ( self , context , volume _ id ) :", "return fakes . stub _ volume ( volume _ id , attach _ status = ' detached ' )", "self . stubs . Set ( volume _ api . API , ' get ' , stub _ volume _ get )", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "res _ dict = self . controller . show ( req , ' 1 ' )", "expected = {", "' volume ' : {", "' status ' : ' fakestatus ' ,", "' display _ description ' : ' displaydesc ' ,", "' availability _ zone ' : ' fakeaz ' ,", "' display _ name ' : ' displayname ' ,", "' attachments ' : [ ] ,", "' volume _ type ' : ' vol _ type _ name ' ,", "' snapshot _ id ' : None ,", "' metadata ' : { } ,", "' id ' : ' 1 ' ,", "' created _ at ' : datetime . datetime ( 1 , 1 , 1 , 1 , 1 , 1 ) ,", "' size ' : 1", "}", "}", "self . assertEqual ( res _ dict , expected )", "def test _ volume _ show _ no _ volume ( self ) :", "self . stubs . Set ( volume _ api . API , `` get `` , fakes . stub _ volume _ get _ notfound )", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "self . assertRaises ( webob . exc . HTTPNotFound , self . controller . show ,", "req , 1 )", "def test _ volume _ delete ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "resp = self . controller . delete ( req , 1 )", "self . assertEqual ( resp . status _ int , 202 )", "def test _ volume _ delete _ no _ volume ( self ) :", "self . stubs . Set ( volume _ api . API , `` get `` , fakes . stub _ volume _ get _ notfound )", "req = fakes . HTTPRequest . blank ( ' / v2 / volumes / 1 ' )", "self . assertRaises ( webob . exc . HTTPNotFound , self . controller . delete ,", "req , 1 )", "def test _ admin _ list _ volumes _ limited _ to _ project ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / volumes ' ,", "use _ admin _ context = True )", "res = self . controller . index ( req )", "self . assertTrue ( ' volumes ' in res )", "self . assertEqual ( 1 , len ( res [ ' volumes ' ] ) )", "def test _ admin _ list _ volumes _ all _ tenants ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / volumes ? all _ tenants = 1 ' ,", "use _ admin _ context = True )", "res = self . controller . index ( req )", "self . assertTrue ( ' volumes ' in res )", "self . assertEqual ( 3 , len ( res [ ' volumes ' ] ) )", "def test _ all _ tenants _ non _ admin _ gets _ all _ tenants ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / volumes ? all _ tenants = 1 ' )", "res = self . controller . index ( req )", "self . assertTrue ( ' volumes ' in res )", "self . assertEqual ( 1 , len ( res [ ' volumes ' ] ) )", "def test _ non _ admin _ get _ by _ project ( self ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / volumes ' )", "res = self . controller . index ( req )", "self . assertTrue ( ' volumes ' in res )", "self . assertEqual ( 1 , len ( res [ ' volumes ' ] ) )", "class VolumeSerializerTest ( test . TestCase ) :", "def _ verify _ volume _ attachment ( self , attach , tree ) :", "for attr in ( ' id ' , ' volume _ id ' , ' server _ id ' , ' device ' ) :", "self . assertEqual ( str ( attach [ attr ] ) , tree . get ( attr ) )", "def _ verify _ volume ( self , vol , tree ) :", "self . assertEqual ( tree . tag , NS + ' volume ' )", "for attr in ( ' id ' , ' status ' , ' size ' , ' availability _ zone ' , ' created _ at ' ,", "' display _ name ' , ' display _ description ' , ' volume _ type ' ,", "' snapshot _ id ' ) :", "self . assertEqual ( str ( vol [ attr ] ) , tree . get ( attr ) )", "for child in tree :", "print child . tag", "self . assertTrue ( child . tag in ( NS + ' attachments ' , NS + ' metadata ' ) )", "if child . tag = = ' attachments ' :", "self . assertEqual ( 1 , len ( child ) )", "self . assertEqual ( ' attachment ' , child [ 0 ] . tag )", "self . _ verify _ volume _ attachment ( vol [ ' attachments ' ] [ 0 ] , child [ 0 ] )", "elif child . tag = = ' metadata ' :", "not _ seen = set ( vol [ ' metadata ' ] . keys ( ) )", "for gr _ child in child :", "self . assertTrue ( gr _ child . get ( `` key `` ) in not _ seen )", "self . assertEqual ( str ( vol [ ' metadata ' ] [ gr _ child . get ( `` key `` ) ] ) ,", "gr _ child . text )", "not _ seen . remove ( gr _ child . get ( ' key ' ) )", "self . assertEqual ( 0 , len ( not _ seen ) )", "def test _ volume _ show _ create _ serializer ( self ) :", "serializer = volumes . VolumeTemplate ( )", "raw _ volume = dict (", "id = ' vol _ id ' ,", "status = ' vol _ status ' ,", "size = 1024 ,", "availability _ zone = ' vol _ availability ' ,", "created _ at = datetime . datetime . now ( ) ,", "attachments = [", "dict (", "id = ' vol _ id ' ,", "volume _ id = ' vol _ id ' ,", "server _ id = ' instance _ uuid ' ,", "device = ' / foo '", ")", "] ,", "display _ name = ' vol _ name ' ,", "display _ description = ' vol _ desc ' ,", "volume _ type = ' vol _ type ' ,", "snapshot _ id = ' snap _ id ' ,", "metadata = dict (", "foo = ' bar ' ,", "baz = ' quux ' ,", ") ,", ")", "text = serializer . serialize ( dict ( volume = raw _ volume ) )", "print text", "tree = etree . fromstring ( text )", "self . _ verify _ volume ( raw _ volume , tree )", "def test _ volume _ index _ detail _ serializer ( self ) :", "serializer = volumes . VolumesTemplate ( )", "raw _ volumes = [", "dict (", "id = ' vol1 _ id ' ,", "status = ' vol1 _ status ' ,", "size = 1024 ,", "availability _ zone = ' vol1 _ availability ' ,", "created _ at = datetime . datetime . now ( ) ,", "attachments = [", "dict (", "id = ' vol1 _ id ' ,", "volume _ id = ' vol1 _ id ' ,", "server _ id = ' instance _ uuid ' ,", "device = ' / foo1 '", ")", "] ,", "display _ name = ' vol1 _ name ' ,", "display _ description = ' vol1 _ desc ' ,", "volume _ type = ' vol1 _ type ' ,", "snapshot _ id = ' snap1 _ id ' ,", "metadata = dict (", "foo = ' vol1 _ foo ' ,", "bar = ' vol1 _ bar ' ,", ") ,", ") ,", "dict (", "id = ' vol2 _ id ' ,", "status = ' vol2 _ status ' ,", "size = 1024 ,", "availability _ zone = ' vol2 _ availability ' ,", "created _ at = datetime . datetime . now ( ) ,", "attachments = [", "dict (", "id = ' vol2 _ id ' ,", "volume _ id = ' vol2 _ id ' ,", "server _ id = ' instance _ uuid ' ,", "device = ' / foo2 ' ) ] ,", "display _ name = ' vol2 _ name ' ,", "display _ description = ' vol2 _ desc ' ,", "volume _ type = ' vol2 _ type ' ,", "snapshot _ id = ' snap2 _ id ' ,", "metadata = dict (", "foo = ' vol2 _ foo ' ,", "bar = ' vol2 _ bar ' ,", ") ,", ")", "]", "text = serializer . serialize ( dict ( volumes = raw _ volumes ) )", "print text", "tree = etree . fromstring ( text )", "self . assertEqual ( NS + ' volumes ' , tree . tag )", "self . assertEqual ( len ( raw _ volumes ) , len ( tree ) )", "for idx , child in enumerate ( tree ) :", "self . _ verify _ volume ( raw _ volumes [ idx ] , child )", "class TestVolumeCreateRequestXMLDeserializer ( test . TestCase ) :", "def setUp ( self ) :", "super ( TestVolumeCreateRequestXMLDeserializer , self ) . setUp ( )", "self . deserializer = volumes . CreateDeserializer ( )", "def test _ minimal _ volume ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 `` > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` size `` : `` 1 `` ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ display _ name ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 ``", "display _ name = `` Volume - xml `` > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` size `` : `` 1 `` ,", "`` display _ name `` : `` Volume - xml `` ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ display _ description ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 ``", "display _ name = `` Volume - xml ``", "display _ description = `` description `` > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` size `` : `` 1 `` ,", "`` display _ name `` : `` Volume - xml `` ,", "`` display _ description `` : `` description `` ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ volume _ type ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 ``", "display _ name = `` Volume - xml ``", "display _ description = `` description ``", "volume _ type = `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 `` > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` display _ name `` : `` Volume - xml `` ,", "`` size `` : `` 1 `` ,", "`` display _ name `` : `` Volume - xml `` ,", "`` display _ description `` : `` description `` ,", "`` volume _ type `` : `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 `` ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ availability _ zone ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 ``", "display _ name = `` Volume - xml ``", "display _ description = `` description ``", "volume _ type = `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 ``", "availability _ zone = `` us - east1 `` > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` size `` : `` 1 `` ,", "`` display _ name `` : `` Volume - xml `` ,", "`` display _ description `` : `` description `` ,", "`` volume _ type `` : `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 `` ,", "`` availability _ zone `` : `` us - east1 `` ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ metadata ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "display _ name = `` Volume - xml ``", "size = `` 1 `` >", "< metadata > < meta key = `` Type `` > work < / meta > < / metadata > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` display _ name `` : `` Volume - xml `` ,", "`` size `` : `` 1 `` ,", "`` metadata `` : {", "`` Type `` : `` work `` ,", "} ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "def test _ full _ volume ( self ) :", "self _ request = `` `` ``", "< volume xmlns = `` http : / / docs . openstack . org / api / openstack - volume / 2 . 0 / content ``", "size = `` 1 ``", "display _ name = `` Volume - xml ``", "display _ description = `` description ``", "volume _ type = `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 ``", "availability _ zone = `` us - east1 `` >", "< metadata > < meta key = `` Type `` > work < / meta > < / metadata > < / volume > `` `` ``", "request = self . deserializer . deserialize ( self _ request )", "expected = {", "`` volume `` : {", "`` size `` : `` 1 `` ,", "`` display _ name `` : `` Volume - xml `` ,", "`` display _ description `` : `` description `` ,", "`` volume _ type `` : `` 289da7f8 - 6440 - 407c - 9fb4 - 7db01ec49164 `` ,", "`` availability _ zone `` : `` us - east1 `` ,", "`` metadata `` : {", "`` Type `` : `` work `` ,", "} ,", "} ,", "}", "self . assertEquals ( request [ ' body ' ] , expected )", "class VolumesUnprocessableEntityTestCase ( test . TestCase ) :", "`` `` ``", "Tests of places we throw 422 Unprocessable Entity from", "`` `` ``", "def setUp ( self ) :", "super ( VolumesUnprocessableEntityTestCase , self ) . setUp ( )", "self . ext _ mgr = extensions . ExtensionManager ( )", "self . ext _ mgr . extensions = { }", "self . controller = volumes . VolumeController ( self . ext _ mgr )", "def _ unprocessable _ volume _ create ( self , body ) :", "req = fakes . HTTPRequest . blank ( ' / v2 / fake / volumes ' )", "req . method = ' POST '", "self . assertRaises ( webob . exc . HTTPUnprocessableEntity ,", "self . controller . create , req , body )", "def test _ create _ no _ body ( self ) :", "self . _ unprocessable _ volume _ create ( body = None )", "def test _ create _ missing _ volume ( self ) :", "body = { ' foo ' : { ' a ' : ' b ' } }", "self . _ unprocessable _ volume _ create ( body = body )", "def test _ create _ malformed _ entity ( self ) :", "body = { ' volume ' : ' string ' }", "self . _ unprocessable _ volume _ create ( body = body )", ],"removed_code":[]},{"added_code":["/ v2 : openstack _ volume _ api _ v2", "[ composite : openstack _ volume _ api _ v2 ]", "use = call : cinder . api . middleware . auth : pipeline _ factory", "noauth = faultwrap sizelimit noauth apiv2", "keystone = faultwrap sizelimit authtoken keystonecontext apiv2", "keystone _ nolimit = faultwrap sizelimit authtoken keystonecontext apiv2", "[ app : apiv2 ]", "paste . app _ factory = cinder . api . v2 . router : APIRouter . factory", ],"removed_code":[]},],[{"added_code":["result [ key ] = ec2utils . glance _ id _ to _ ec2 _ id ( context , kernel _ uuid , ' aki ' )", "result [ key ] = ec2utils . glance _ id _ to _ ec2 _ id ( context , ramdisk _ uuid ,", "' ari ' )", "i [ ' imageId ' ] = ec2utils . glance _ id _ to _ ec2 _ id ( context , image _ uuid )", "kwargs [ ' kernel _ id ' ] = ec2utils . id _ to _ glance _ id ( context ,", "kernel [ ' id ' ] )", "kwargs [ ' ramdisk _ id ' ] = ec2utils . id _ to _ glance _ id ( context ,", "ramdisk [ ' id ' ] )", "image _ uuid = ec2utils . id _ to _ glance _ id ( context , image [ ' id ' ] )", ],"removed_code":["kernel _ id = self . _ get _ image _ id ( context , kernel _ uuid )", "result [ key ] = ec2utils . image _ ec2 _ id ( kernel _ id , ' aki ' )", "ramdisk _ id = self . _ get _ image _ id ( context , ramdisk _ uuid )", "result [ key ] = ec2utils . image _ ec2 _ id ( ramdisk _ id , ' ari ' )", "image _ id = self . _ get _ image _ id ( context , image _ uuid )", "i [ ' imageId ' ] = ec2utils . image _ ec2 _ id ( image _ id )", "kwargs [ ' kernel _ id ' ] = self . _ get _ image _ uuid ( context , kernel [ ' id ' ] )", "kwargs [ ' ramdisk _ id ' ] = self . _ get _ image _ uuid ( context ,", "ramdisk [ ' id ' ] )", "image _ uuid = self . _ get _ image _ uuid ( context , image [ ' id ' ] )", "# NOTE ( bcwaldon ) : We need access to the image uuid since we directly", "# call the compute api from this class", "def _ get _ image _ uuid ( self , context , internal _ id ) :", "return self . image _ service . get _ image _ uuid ( context , internal _ id )", "# NOTE ( bcwaldon ) : We also need to be able to map image uuids to integers", "def _ get _ image _ id ( self , context , image _ uuid ) :", "return self . image _ service . get _ image _ id ( context , image _ uuid )", ]},{"added_code":["from nova import db", "def id _ to _ glance _ id ( context , image _ id ) :", "`` `` `` Convert an internal ( db ) id to a glance id . `` `` ``", "return db . s3 _ image _ get ( context , image _ id ) [ ' uuid ' ]", "def glance _ id _ to _ id ( context , glance _ id ) :", "`` `` `` Convert a glance id to an internal ( db ) id . `` `` ``", "if glance _ id is None :", "return", "try :", "return db . s3 _ image _ get _ by _ uuid ( context , glance _ id ) [ ' id ' ]", "except exception . NotFound :", "return db . s3 _ image _ create ( context , glance _ id ) [ ' id ' ]", "def ec2 _ id _ to _ glance _ id ( context , ec2 _ id ) :", "image _ id = ec2 _ id _ to _ id ( ec2 _ id )", "return id _ to _ glance _ id ( context , image _ id )", "def glance _ id _ to _ ec2 _ id ( context , glance _ id , image _ type = ' ami ' ) :", "image _ id = glance _ id _ to _ id ( context , glance _ id )", "return image _ ec2 _ id ( image _ id , image _ type = image _ type )", ],"removed_code":[]},{"added_code":["image _ uuid = image _ copy [ ' id ' ]", "image _ copy [ ' id ' ] = ec2utils . glance _ id _ to _ id ( context , image _ uuid )", "image _ id = ec2utils . glance _ id _ to _ id ( context , image _ uuid )", "image _ copy [ ' properties ' ] [ prop ] = image _ id", "image _ copy [ ' id ' ] = ec2utils . id _ to _ glance _ id ( context , image _ id )", "image _ uuid = ec2utils . id _ to _ glance _ id ( context , image _ id )", "image _ uuid = ec2utils . id _ to _ glance _ id ( context , image _ id )", "image _ uuid = ec2utils . id _ to _ glance _ id ( context , image _ id )", "image _ uuid = ec2utils . id _ to _ glance _ id ( context , image _ id )", "image _ uuid = ec2utils . ec2 _ id _ to _ glance _ id ( context , image _ id )", "image [ ' id ' ] = ec2utils . glance _ id _ to _ id ( context , image _ uuid )", ],"removed_code":["import nova . db . api", "def get _ image _ uuid ( self , context , image _ id ) :", "return nova . db . api . s3 _ image _ get ( context , image _ id ) [ ' uuid ' ]", "def get _ image _ id ( self , context , image _ uuid ) :", "return nova . db . api . s3 _ image _ get _ by _ uuid ( context , image _ uuid ) [ ' id ' ]", "def _ create _ image _ id ( self , context , image _ uuid ) :", "return nova . db . api . s3 _ image _ create ( context , image _ uuid ) [ ' id ' ]", "def _ find _ or _ create ( image _ uuid ) :", "if image _ uuid is None :", "return", "try :", "return self . get _ image _ id ( context , image _ uuid )", "except exception . NotFound :", "return self . _ create _ image _ id ( context , image _ uuid )", "image _ id = image _ copy [ ' id ' ]", "image _ copy [ ' id ' ] = _ find _ or _ create ( image _ id )", "image _ copy [ ' properties ' ] [ prop ] = _ find _ or _ create ( image _ uuid )", "image _ copy [ ' id ' ] = self . get _ image _ uuid ( context , image _ id )", "image _ uuid = self . get _ image _ uuid ( context , image _ id )", "image _ uuid = self . get _ image _ uuid ( context , image _ id )", "image _ uuid = self . get _ image _ uuid ( context , image _ id )", "image _ uuid = self . get _ image _ uuid ( context , image _ id )", "image _ id = ec2utils . ec2 _ id _ to _ id ( image _ id )", "image _ uuid = self . get _ image _ uuid ( context , image _ id )", "image [ ' id ' ] = self . _ create _ image _ id ( context , image _ uuid )", ]},],[{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", ],"removed_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", ]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", ],"removed_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", ]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Unit tests for Windows Hyper - V virtual switch quantum driver", "`` `` ``", "class TestHyperVQuantumAgent ( unittest . TestCase ) :", "def setUp ( self ) :", "self . addCleanup ( cfg . CONF . reset )", "# Avoid rpc initialization for unit tests", "cfg . CONF . set _ override ( ' rpc _ backend ' ,", "' quantum . openstack . common . rpc . impl _ fake ' )", "self . agent = hyperv _ quantum _ agent . HyperVQuantumAgent ( )", "self . agent . plugin _ rpc = mock . Mock ( )", "self . agent . context = mock . Mock ( )", "self . agent . agent _ id = mock . Mock ( )", "self . agent . _ utils = mock . Mock ( )", "def tearDown ( self ) :", "cfg . CONF . reset ( )", "def test _ port _ bound ( self ) :", "port = mock . Mock ( )", "net _ uuid = ' my - net - uuid '", "with mock . patch . object (", "self . agent . _ utils , ' connect _ vnic _ to _ vswitch ' ) :", "with mock . patch . object (", "self . agent . _ utils , ' set _ vswitch _ port _ vlan _ id ' ) :", "self . agent . _ port _ bound ( port , net _ uuid , ' vlan ' , None , None )", "def test _ port _ unbound ( self ) :", "map = {", "' network _ type ' : ' vlan ' ,", "' vswitch _ name ' : ' fake - vswitch ' ,", "' ports ' : [ ] ,", "' vlan _ id ' : 1 }", "net _ uuid = ' my - net - uuid '", "network _ vswitch _ map = ( net _ uuid , map )", "with mock . patch . object ( self . agent ,", "' _ get _ network _ vswitch _ map _ by _ port _ id ' ,", "return _ value = network _ vswitch _ map ) :", "with mock . patch . object (", "self . agent . _ utils ,", "' disconnect _ switch _ port ' ) :", "self . agent . _ port _ unbound ( net _ uuid )", "def test _ treat _ devices _ added _ returns _ true _ for _ missing _ device ( self ) :", "attrs = { ' get _ device _ details . side _ effect ' : Exception ( ) }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "self . assertTrue ( self . agent . _ treat _ devices _ added ( [ { } ] ) )", "def mock _ treat _ devices _ added ( self , details , func _ name ) :", "`` `` ``", ": param details : the details to return for the device", ": param func _ name : the function that should be called", ": returns : whether the named function was called", "`` `` ``", "attrs = { ' get _ device _ details . return _ value ' : details }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "with mock . patch . object ( self . agent , func _ name ) as func :", "self . assertFalse ( self . agent . _ treat _ devices _ added ( [ { } ] ) )", "return func . called", "def test _ treat _ devices _ added _ updates _ known _ port ( self ) :", "details = mock . MagicMock ( )", "details . _ _ contains _ _ . side _ effect = lambda x : True", "self . assertTrue ( self . mock _ treat _ devices _ added ( details ,", "' _ treat _ vif _ port ' ) )", "def test _ treat _ devices _ removed _ returns _ true _ for _ missing _ device ( self ) :", "attrs = { ' update _ device _ down . side _ effect ' : Exception ( ) }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "self . assertTrue ( self . agent . _ treat _ devices _ removed ( [ { } ] ) )", "def mock _ treat _ devices _ removed ( self , port _ exists ) :", "details = dict ( exists = port _ exists )", "attrs = { ' update _ device _ down . return _ value ' : details }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "with mock . patch . object ( self . agent , ' _ port _ unbound ' ) as func :", "self . assertFalse ( self . agent . _ treat _ devices _ removed ( [ { } ] ) )", "self . assertEqual ( func . called , not port _ exists )", "def test _ treat _ devices _ removed _ unbinds _ port ( self ) :", "self . mock _ treat _ devices _ removed ( False )", "def test _ treat _ devices _ removed _ ignores _ missing _ port ( self ) :", "self . mock _ treat _ devices _ removed ( False )", ],"removed_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Unit tests for Windows Hyper - V virtual switch quantum driver", "`` `` ``", "class TestHyperVQuantumAgent ( unittest . TestCase ) :", "def setUp ( self ) :", "self . addCleanup ( cfg . CONF . reset )", "# Avoid rpc initialization for unit tests", "cfg . CONF . set _ override ( ' rpc _ backend ' ,", "' quantum . openstack . common . rpc . impl _ fake ' )", "self . agent = hyperv _ quantum _ agent . HyperVQuantumAgent ( )", "self . agent . plugin _ rpc = mock . Mock ( )", "self . agent . context = mock . Mock ( )", "self . agent . agent _ id = mock . Mock ( )", "self . agent . _ utils = mock . Mock ( )", "def tearDown ( self ) :", "cfg . CONF . reset ( )", "def test _ port _ bound ( self ) :", "port = mock . Mock ( )", "net _ uuid = ' my - net - uuid '", "with mock . patch . object (", "self . agent . _ utils , ' connect _ vnic _ to _ vswitch ' ) :", "with mock . patch . object (", "self . agent . _ utils , ' set _ vswitch _ port _ vlan _ id ' ) :", "self . agent . _ port _ bound ( port , net _ uuid , ' vlan ' , None , None )", "def test _ port _ unbound ( self ) :", "map = {", "' network _ type ' : ' vlan ' ,", "' vswitch _ name ' : ' fake - vswitch ' ,", "' ports ' : [ ] ,", "' vlan _ id ' : 1 }", "net _ uuid = ' my - net - uuid '", "network _ vswitch _ map = ( net _ uuid , map )", "with mock . patch . object ( self . agent ,", "' _ get _ network _ vswitch _ map _ by _ port _ id ' ,", "return _ value = network _ vswitch _ map ) :", "with mock . patch . object (", "self . agent . _ utils ,", "' disconnect _ switch _ port ' ) :", "self . agent . _ port _ unbound ( net _ uuid )", "def test _ treat _ devices _ added _ returns _ true _ for _ missing _ device ( self ) :", "attrs = { ' get _ device _ details . side _ effect ' : Exception ( ) }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "self . assertTrue ( self . agent . _ treat _ devices _ added ( [ { } ] ) )", "def mock _ treat _ devices _ added ( self , details , func _ name ) :", "`` `` ``", ": param details : the details to return for the device", ": param func _ name : the function that should be called", ": returns : whether the named function was called", "`` `` ``", "attrs = { ' get _ device _ details . return _ value ' : details }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "with mock . patch . object ( self . agent , func _ name ) as func :", "self . assertFalse ( self . agent . _ treat _ devices _ added ( [ { } ] ) )", "return func . called", "def test _ treat _ devices _ added _ updates _ known _ port ( self ) :", "details = mock . MagicMock ( )", "details . _ _ contains _ _ . side _ effect = lambda x : True", "self . assertTrue ( self . mock _ treat _ devices _ added ( details ,", "' _ treat _ vif _ port ' ) )", "def test _ treat _ devices _ removed _ returns _ true _ for _ missing _ device ( self ) :", "attrs = { ' update _ device _ down . side _ effect ' : Exception ( ) }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "self . assertTrue ( self . agent . _ treat _ devices _ removed ( [ { } ] ) )", "def mock _ treat _ devices _ removed ( self , port _ exists ) :", "details = dict ( exists = port _ exists )", "attrs = { ' update _ device _ down . return _ value ' : details }", "self . agent . plugin _ rpc . configure _ mock ( * * attrs )", "with mock . patch . object ( self . agent , ' _ port _ unbound ' ) as func :", "self . assertFalse ( self . agent . _ treat _ devices _ removed ( [ { } ] ) )", "self . assertEqual ( func . called , not port _ exists )", "def test _ treat _ devices _ removed _ unbinds _ port ( self ) :", "self . mock _ treat _ devices _ removed ( False )", "def test _ treat _ devices _ removed _ ignores _ missing _ port ( self ) :", "self . mock _ treat _ devices _ removed ( False )", ]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "class HyperVQuantumPluginTestCase ( test _ plugin . QuantumDbPluginV2TestCase ) :", "_ plugin _ name = ( ' quantum . plugins . hyperv . '", "' hyperv _ quantum _ plugin . HyperVQuantumPlugin ' )", "def setUp ( self ) :", "super ( HyperVQuantumPluginTestCase , self ) . setUp ( self . _ plugin _ name )", "class TestHyperVVirtualSwitchBasicGet (", "test _ plugin . TestBasicGet , HyperVQuantumPluginTestCase ) :", "pass", "class TestHyperVVirtualSwitchV2HTTPResponse (", "test _ plugin . TestV2HTTPResponse , HyperVQuantumPluginTestCase ) :", "pass", "class TestHyperVVirtualSwitchPortsV2 (", "test _ plugin . TestPortsV2 , HyperVQuantumPluginTestCase ) :", "def test _ port _ vif _ details ( self ) :", "plugin = QuantumManager . get _ plugin ( )", "with self . port ( name = ' name ' ) as port :", "port _ id = port [ ' port ' ] [ ' id ' ]", "self . assertEqual ( port [ ' port ' ] [ ' binding : vif _ type ' ] ,", "portbindings . VIF _ TYPE _ HYPERV )", "# By default user is admin - now test non admin user", "ctx = context . Context ( user _ id = None ,", "tenant _ id = self . _ tenant _ id ,", "is _ admin = False ,", "read _ deleted = `` no `` )", "non _ admin _ port = plugin . get _ port ( ctx , port _ id )", "self . assertTrue ( ' status ' in non _ admin _ port )", "self . assertFalse ( ' binding : vif _ type ' in non _ admin _ port )", "def test _ ports _ vif _ details ( self ) :", "cfg . CONF . set _ default ( ' allow _ overlapping _ ips ' , True )", "plugin = QuantumManager . get _ plugin ( )", "with contextlib . nested ( self . port ( ) , self . port ( ) ) as ( port1 , port2 ) :", "ctx = context . get _ admin _ context ( )", "ports = plugin . get _ ports ( ctx )", "self . assertEqual ( len ( ports ) , 2 )", "for port in ports :", "self . assertEqual ( port [ ' binding : vif _ type ' ] ,", "portbindings . VIF _ TYPE _ HYPERV )", "# By default user is admin - now test non admin user", "ctx = context . Context ( user _ id = None ,", "tenant _ id = self . _ tenant _ id ,", "is _ admin = False ,", "read _ deleted = `` no `` )", "ports = plugin . get _ ports ( ctx )", "self . assertEqual ( len ( ports ) , 2 )", "for non _ admin _ port in ports :", "self . assertTrue ( ' status ' in non _ admin _ port )", "self . assertFalse ( ' binding : vif _ type ' in non _ admin _ port )", "class TestHyperVVirtualSwitchNetworksV2 (", "test _ plugin . TestNetworksV2 , HyperVQuantumPluginTestCase ) :", "pass", ],"removed_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "class HyperVQuantumPluginTestCase ( test _ plugin . QuantumDbPluginV2TestCase ) :", "_ plugin _ name = ( ' quantum . plugins . hyperv . '", "' hyperv _ quantum _ plugin . HyperVQuantumPlugin ' )", "def setUp ( self ) :", "super ( HyperVQuantumPluginTestCase , self ) . setUp ( self . _ plugin _ name )", "class TestHyperVVirtualSwitchBasicGet (", "test _ plugin . TestBasicGet , HyperVQuantumPluginTestCase ) :", "pass", "class TestHyperVVirtualSwitchV2HTTPResponse (", "test _ plugin . TestV2HTTPResponse , HyperVQuantumPluginTestCase ) :", "pass", "class TestHyperVVirtualSwitchPortsV2 (", "test _ plugin . TestPortsV2 , HyperVQuantumPluginTestCase ) :", "def test _ port _ vif _ details ( self ) :", "plugin = QuantumManager . get _ plugin ( )", "with self . port ( name = ' name ' ) as port :", "port _ id = port [ ' port ' ] [ ' id ' ]", "self . assertEqual ( port [ ' port ' ] [ ' binding : vif _ type ' ] ,", "portbindings . VIF _ TYPE _ HYPERV )", "# By default user is admin - now test non admin user", "ctx = context . Context ( user _ id = None ,", "tenant _ id = self . _ tenant _ id ,", "is _ admin = False ,", "read _ deleted = `` no `` )", "non _ admin _ port = plugin . get _ port ( ctx , port _ id )", "self . assertTrue ( ' status ' in non _ admin _ port )", "self . assertFalse ( ' binding : vif _ type ' in non _ admin _ port )", "def test _ ports _ vif _ details ( self ) :", "cfg . CONF . set _ default ( ' allow _ overlapping _ ips ' , True )", "plugin = QuantumManager . get _ plugin ( )", "with contextlib . nested ( self . port ( ) , self . port ( ) ) as ( port1 , port2 ) :", "ctx = context . get _ admin _ context ( )", "ports = plugin . get _ ports ( ctx )", "self . assertEqual ( len ( ports ) , 2 )", "for port in ports :", "self . assertEqual ( port [ ' binding : vif _ type ' ] ,", "portbindings . VIF _ TYPE _ HYPERV )", "# By default user is admin - now test non admin user", "ctx = context . Context ( user _ id = None ,", "tenant _ id = self . _ tenant _ id ,", "is _ admin = False ,", "read _ deleted = `` no `` )", "ports = plugin . get _ ports ( ctx )", "self . assertEqual ( len ( ports ) , 2 )", "for non _ admin _ port in ports :", "self . assertTrue ( ' status ' in non _ admin _ port )", "self . assertFalse ( ' binding : vif _ type ' in non _ admin _ port )", "class TestHyperVVirtualSwitchNetworksV2 (", "test _ plugin . TestNetworksV2 , HyperVQuantumPluginTestCase ) :", "pass", ]},{"added_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Unit Tests for hyperv quantum rpc", "`` `` ``", "class rpcHyperVApiTestCase ( unittest2 . TestCase ) :", "def _ test _ hyperv _ quantum _ api (", "self , rpcapi , topic , method , rpc _ method , * * kwargs ) :", "ctxt = context . RequestContext ( ' fake _ user ' , ' fake _ project ' )", "expected _ retval = ' foo ' if method = = ' call ' else None", "expected _ msg = rpcapi . make _ msg ( method , * * kwargs )", "expected _ msg [ ' version ' ] = rpcapi . BASE _ RPC _ API _ VERSION", "if rpc _ method = = ' cast ' and method = = ' run _ instance ' :", "kwargs [ ' call ' ] = False", "rpc _ method _ mock = mock . Mock ( )", "rpc _ method _ mock . return _ value = expected _ retval", "setattr ( rpc , rpc _ method , rpc _ method _ mock )", "retval = getattr ( rpcapi , method ) ( ctxt , * * kwargs )", "self . assertEqual ( retval , expected _ retval )", "expected _ args = [ ctxt , topic , expected _ msg ]", "for arg , expected _ arg in zip ( rpc _ method _ mock . call _ args [ 0 ] ,", "expected _ args ) :", "self . assertEqual ( arg , expected _ arg )", "def test _ delete _ network ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . NETWORK ,", "topics . DELETE ) ,", "' network _ delete ' , rpc _ method = ' fanout _ cast ' ,", "network _ id = ' fake _ request _ spec ' )", "def test _ port _ update ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . PORT ,", "topics . UPDATE ) ,", "' port _ update ' , rpc _ method = ' fanout _ cast ' ,", "port = ' fake _ port ' ,", "network _ type = ' fake _ network _ type ' ,", "segmentation _ id = ' fake _ segmentation _ id ' ,", "physical _ network = ' fake _ physical _ network ' )", "def test _ port _ delete ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . PORT ,", "topics . DELETE ) ,", "' port _ delete ' , rpc _ method = ' fanout _ cast ' ,", "port _ id = ' port _ id ' )", "def test _ tunnel _ update ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "constants . TUNNEL ,", "topics . UPDATE ) ,", "' tunnel _ update ' , rpc _ method = ' fanout _ cast ' ,", "tunnel _ ip = ' fake _ ip ' , tunnel _ id = ' fake _ id ' )", "def test _ device _ details ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' get _ device _ details ' , rpc _ method = ' call ' ,", "device = ' fake _ device ' ,", "agent _ id = ' fake _ agent _ id ' )", "def test _ update _ device _ down ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' update _ device _ down ' , rpc _ method = ' call ' ,", "device = ' fake _ device ' ,", "agent _ id = ' fake _ agent _ id ' )", "def test _ tunnel _ sync ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' tunnel _ sync ' , rpc _ method = ' call ' ,", "tunnel _ ip = ' fake _ tunnel _ ip ' )", ],"removed_code":["vim : tabstop = 4 shiftwidth = 4 softtabstop = 4", "Copyright 2013 Cloudbase Solutions SRL", "Copyright 2013 Pedro Navarro Perez", "All Rights Reserved .", "", "Licensed under the Apache License , Version 2 . 0 ( the `` License `` ) ; you may", "not use this file except in compliance with the License . You may obtain", "a copy of the License at", "", "http : / / www . apache . org / licenses / LICENSE - 2 . 0", "", "Unless required by applicable law or agreed to in writing , software", "distributed under the License is distributed on an `` AS IS `` BASIS , WITHOUT", "WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the", "License for the specific language governing permissions and limitations", "under the License .", "`` `` ``", "Unit Tests for hyperv quantum rpc", "`` `` ``", "class rpcHyperVApiTestCase ( unittest2 . TestCase ) :", "def _ test _ hyperv _ quantum _ api (", "self , rpcapi , topic , method , rpc _ method , * * kwargs ) :", "ctxt = context . RequestContext ( ' fake _ user ' , ' fake _ project ' )", "expected _ retval = ' foo ' if method = = ' call ' else None", "expected _ msg = rpcapi . make _ msg ( method , * * kwargs )", "expected _ msg [ ' version ' ] = rpcapi . BASE _ RPC _ API _ VERSION", "if rpc _ method = = ' cast ' and method = = ' run _ instance ' :", "kwargs [ ' call ' ] = False", "rpc _ method _ mock = mock . Mock ( )", "rpc _ method _ mock . return _ value = expected _ retval", "setattr ( rpc , rpc _ method , rpc _ method _ mock )", "retval = getattr ( rpcapi , method ) ( ctxt , * * kwargs )", "self . assertEqual ( retval , expected _ retval )", "expected _ args = [ ctxt , topic , expected _ msg ]", "for arg , expected _ arg in zip ( rpc _ method _ mock . call _ args [ 0 ] ,", "expected _ args ) :", "self . assertEqual ( arg , expected _ arg )", "def test _ delete _ network ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . NETWORK ,", "topics . DELETE ) ,", "' network _ delete ' , rpc _ method = ' fanout _ cast ' ,", "network _ id = ' fake _ request _ spec ' )", "def test _ port _ update ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . PORT ,", "topics . UPDATE ) ,", "' port _ update ' , rpc _ method = ' fanout _ cast ' ,", "port = ' fake _ port ' ,", "network _ type = ' fake _ network _ type ' ,", "segmentation _ id = ' fake _ segmentation _ id ' ,", "physical _ network = ' fake _ physical _ network ' )", "def test _ port _ delete ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "topics . PORT ,", "topics . DELETE ) ,", "' port _ delete ' , rpc _ method = ' fanout _ cast ' ,", "port _ id = ' port _ id ' )", "def test _ tunnel _ update ( self ) :", "rpcapi = ana . AgentNotifierApi ( topics . AGENT )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi ,", "topics . get _ topic _ name (", "topics . AGENT ,", "constants . TUNNEL ,", "topics . UPDATE ) ,", "' tunnel _ update ' , rpc _ method = ' fanout _ cast ' ,", "tunnel _ ip = ' fake _ ip ' , tunnel _ id = ' fake _ id ' )", "def test _ device _ details ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' get _ device _ details ' , rpc _ method = ' call ' ,", "device = ' fake _ device ' ,", "agent _ id = ' fake _ agent _ id ' )", "def test _ update _ device _ down ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' update _ device _ down ' , rpc _ method = ' call ' ,", "device = ' fake _ device ' ,", "agent _ id = ' fake _ agent _ id ' )", "def test _ tunnel _ sync ( self ) :", "rpcapi = agent _ rpc . PluginApi ( topics . PLUGIN )", "self . _ test _ hyperv _ quantum _ api (", "rpcapi , topics . PLUGIN ,", "' tunnel _ sync ' , rpc _ method = ' call ' ,", "tunnel _ ip = ' fake _ tunnel _ ip ' )", ]},],[{"added_code":["def update _ device _ down ( self , context , device , agent _ id , host = None ) :", "agent _ id = agent _ id , host = host ) ,", "def update _ device _ up ( self , context , device , agent _ id , host = None ) :", "agent _ id = agent _ id , host = host ) ,", ],"removed_code":["def update _ device _ down ( self , context , device , agent _ id ) :", "agent _ id = agent _ id ) ,", "def update _ device _ up ( self , context , device , agent _ id ) :", "agent _ id = agent _ id ) ,", ]},{"added_code":["self . agent _ id ,", "cfg . CONF . host )", ],"removed_code":["self . agent _ id )", ]},{"added_code":["self . agent . agent _ id ,", "cfg . CONF . host )", "self . agent . agent _ id ,", "cfg . CONF . host )", "self . agent . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", ],"removed_code":["self . agent . agent _ id )", "self . agent . agent _ id )", "self . agent . agent _ id )", "self . agent _ id )", "self . agent _ id )", "self . agent _ id )", ]},{"added_code":["from neutron import manager", "host = kwargs . get ( ' host ' )", "port = self . get _ port _ from _ device ( device )", "plugin = manager . NeutronManager . get _ plugin ( )", "if ( host and not", "plugin . get _ port _ host ( rpc _ context , port [ ' id ' ] ) = = host ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "elif port [ ' status ' ] ! = q _ const . PORT _ STATUS _ DOWN :", "host = kwargs . get ( ' host ' )", "port = self . get _ port _ from _ device . get _ port ( device )", "LOG . debug ( _ ( `` Device % ( device ) s up on % ( agent _ id ) s `` ) ,", "plugin = manager . NeutronManager . get _ plugin ( )", "if ( host and", "not plugin . get _ port _ host ( rpc _ context , port [ ' id ' ] ) = = host ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "return", "elif port [ ' status ' ] ! = q _ const . PORT _ STATUS _ ACTIVE :", "db . set _ port _ status ( port [ ' id ' ] ,", "q _ const . PORT _ STATUS _ ACTIVE )", ],"removed_code":["port = self . get _ port _ from _ device ( device )", "if port [ ' status ' ] ! = q _ const . PORT _ STATUS _ DOWN :", "LOG . debug ( _ ( `` Device % ( device ) s up % ( agent _ id ) s `` ) ,", "port = self . get _ port _ from _ device ( device )", "if port [ ' status ' ] ! = q _ const . PORT _ STATUS _ ACTIVE :", "# Set port status to ACTIVE", "db . set _ port _ status ( port [ ' id ' ] , q _ const . PORT _ STATUS _ ACTIVE )", ]},{"added_code":["def get _ port _ binding _ host ( port _ id ) :", "session = db _ api . get _ session ( )", "with session . begin ( subtransactions = True ) :", "try :", "query = ( session . query ( models . PortBinding ) .", "filter ( models . PortBinding . port _ id . startswith ( port _ id ) ) .", "one ( ) )", "except exc . NoResultFound :", "LOG . debug ( _ ( `` No binding found for port % ( port _ id ) s `` ) ,", "{ ' port _ id ' : port _ id } )", "return", "return query . host", ],"removed_code":[]},{"added_code":["def port _ bound _ to _ host ( self , port _ id , host ) :", "port _ host = db . get _ port _ binding _ host ( port _ id )", "return ( port _ host = = host )", ],"removed_code":[]},{"added_code":["host = kwargs . get ( ' host ' )", "plugin = manager . NeutronManager . get _ plugin ( )", "port _ exists = True", "if ( host and not plugin . port _ bound _ to _ host ( port _ id , host ) ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "return { ' device ' : device ,", "' exists ' : port _ exists }", "host = kwargs . get ( ' host ' )", "plugin = manager . NeutronManager . get _ plugin ( )", "if ( host and not plugin . port _ bound _ to _ host ( port _ id , host ) ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "return", ],"removed_code":["plugin = manager . NeutronManager . get _ plugin ( )", "plugin = manager . NeutronManager . get _ plugin ( )", ]},{"added_code":["self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", "self . agent _ id ,", "cfg . CONF . host )", ],"removed_code":["self . agent _ id )", "self . agent _ id )", "self . agent _ id )", "self . agent _ id )", "self . agent _ id )", "self . agent _ id )", ]},{"added_code":["from neutron import manager", "host = kwargs . get ( ' host ' )", "port = ovs _ db _ v2 . get _ port ( device )", "plugin = manager . NeutronManager . get _ plugin ( )", "if ( host and", "not plugin . get _ port _ host ( rpc _ context , port [ ' id ' ] ) = = host ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "elif port [ ' status ' ] ! = q _ const . PORT _ STATUS _ DOWN :", "ovs _ db _ v2 . set _ port _ status ( port [ ' id ' ] ,", "q _ const . PORT _ STATUS _ DOWN )", "host = kwargs . get ( ' host ' )", "port = ovs _ db _ v2 . get _ port ( device )", "plugin = manager . NeutronManager . get _ plugin ( )", "if ( host and", "not plugin . get _ port _ host ( rpc _ context , port [ ' id ' ] ) = = host ) :", "LOG . debug ( _ ( `` Device % ( device ) s not bound to the ``", "`` agent host % ( host ) s `` ) ,", "{ ' device ' : device , ' host ' : host } )", "return", "elif port [ ' status ' ] ! = q _ const . PORT _ STATUS _ ACTIVE :", ],"removed_code":["# TODO ( garyk ) - live migration and port status", "port = ovs _ db _ v2 . get _ port ( device )", "if port [ ' status ' ] ! = q _ const . PORT _ STATUS _ DOWN :", "ovs _ db _ v2 . set _ port _ status ( port [ ' id ' ] , q _ const . PORT _ STATUS _ DOWN )", "port = ovs _ db _ v2 . get _ port ( device )", "if port [ ' status ' ] ! = q _ const . PORT _ STATUS _ ACTIVE :", ]},{"added_code":["agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", ],"removed_code":["agent _ id = ' fake _ agent _ id ' )", ]},{"added_code":["self . lb _ rpc . agent . agent _ id ,", "cfg . CONF . host", ],"removed_code":["self . lb _ rpc . agent . agent _ id", ]},{"added_code":["agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", "agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", ],"removed_code":["agent _ id = ' fake _ agent _ id ' )", "agent _ id = ' fake _ agent _ id ' )", ]},{"added_code":["agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", "agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", ],"removed_code":["agent _ id = ' fake _ agent _ id ' )", "agent _ id = ' fake _ agent _ id ' )", ]},{"added_code":["agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", "agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", ],"removed_code":["agent _ id = ' fake _ agent _ id ' )", "agent _ id = ' fake _ agent _ id ' )", ]},{"added_code":["`` 123 `` , self . agent . agent _ id ,", "cfg . CONF . host )", "`` 123 `` , self . agent . agent _ id ,", "cfg . CONF . host )", ],"removed_code":["`` 123 `` , self . agent . agent _ id )", "`` 123 `` , self . agent . agent _ id )", ]},{"added_code":["agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", "agent _ id = ' fake _ agent _ id ' ,", "host = ' fake _ host ' )", ],"removed_code":["agent _ id = ' fake _ agent _ id ' )", "agent _ id = ' fake _ agent _ id ' )", ]},],[{"added_code":["vif _ port = lvm . vif _ ports . pop ( vif _ id , None )", "if vif _ port :", "if self . enable _ tunneling and lvm . network _ type = = ' gre ' :", "dl _ dst = vif _ port . vif _ mac )", ],"removed_code":["if vif _ id in lvm . vif _ ports :", "if lvm . network _ type = = ' gre ' and self . enable _ tunneling :", "dl _ dst = lvm . vif _ ports [ vif _ id ] . vif _ mac )", "del lvm . vif _ ports [ vif _ id ]", ]},],[{"added_code":["from glance . common import utils", "import glance . domain", "class ImageRepoProxy ( glance . domain . ImageRepoProxy ) :", "def _ _ init _ _ ( self , context , policy , image _ repo ) :", "self . _ context = context", "self . _ policy = policy", "self . _ image _ repo = image _ repo", "super ( ImageRepoProxy , self ) . _ _ init _ _ ( image _ repo )", "def get ( self , * args , * * kwargs ) :", "self . _ policy . enforce ( self . _ context , ' get _ image ' , { } )", "image = self . _ image _ repo . get ( * args , * * kwargs )", "return ImageProxy ( image , self . _ context , self . _ policy )", "def list ( self , * args , * * kwargs ) :", "self . _ policy . enforce ( self . _ context , ' get _ images ' , { } )", "images = self . _ image _ repo . list ( * args , * * kwargs )", "return [ ImageProxy ( i , self . _ context , self . _ policy )", "for i in images ]", "def save ( self , * args , * * kwargs ) :", "self . _ policy . enforce ( self . _ context , ' modify _ image ' , { } )", "return self . _ image _ repo . save ( * args , * * kwargs )", "def add ( self , * args , * * kwargs ) :", "self . _ policy . enforce ( self . _ context , ' add _ image ' , { } )", "return self . _ image _ repo . add ( * args , * * kwargs )", "class ImageProxy ( glance . domain . ImageProxy ) :", "def _ _ init _ _ ( self , image , context , policy ) :", "self . _ image = image", "self . _ context = context", "self . _ policy = policy", "super ( ImageProxy , self ) . _ _ init _ _ ( image )", "@ property", "def visibility ( self ) :", "return self . _ image . visibility", "@ visibility . setter", "def visibility ( self , value ) :", "if value = = ' public ' :", "self . _ policy . enforce ( self . _ context , ' publicize _ image ' , { } )", "self . _ image . visibility = value", "def delete ( self ) :", "self . _ policy . enforce ( self . _ context , ' delete _ image ' , { } )", "return self . _ image . delete ( )", "class ImageFactoryProxy ( object ) :", "def _ _ init _ _ ( self , image _ factory , context , policy ) :", "self . image _ factory = image _ factory", "self . context = context", "self . policy = policy", "def new _ image ( self , * * kwargs ) :", "if kwargs . get ( ' visibility ' ) = = ' public ' :", "self . policy . enforce ( self . context , ' publicize _ image ' , { } )", "image = self . image _ factory . new _ image ( * * kwargs )", "return image", ],"removed_code":[]},{"added_code":["from glance . tests . unit import utils as unit _ test _ utils", "UUID1 = ' c80a1a6c - bd1f - 41c5 - 90ee - 81afedb1d58d '", "class ImageRepoStub ( object ) :", "def get ( self , * args , * * kwargs ) :", "return ' image _ from _ get '", "def save ( self , * args , * * kwargs ) :", "return ' image _ from _ save '", "def add ( self , * args , * * kwargs ) :", "return ' image _ from _ add '", "def list ( self , * args , * * kwargs ) :", "return [ ' image _ from _ list _ 0 ' , ' image _ from _ list _ 1 ' ]", "class ImageStub ( object ) :", "def _ _ init _ _ ( self , image _ id , visibility = ' private ' ) :", "self . image _ id = image _ id", "self . visibility = visibility", "self . status = ' active '", "def delete ( self ) :", "self . status = ' deleted '", "class ImageFactoryStub ( object ) :", "def new _ image ( self , image _ id = None , name = None , visibility = ' private ' ,", "min _ disk = 0 , min _ ram = 0 , protected = False , owner = None ,", "disk _ format = None , container _ format = None ,", "extra _ properties = None , tags = None , * * other _ args ) :", "self . visibility = visibility", "return ' new _ image '", "class TestImagePolicy ( test _ utils . BaseTestCase ) :", "def setUp ( self ) :", "self . image _ stub = ImageStub ( UUID1 )", "self . image _ repo _ stub = ImageRepoStub ( )", "self . image _ factory _ stub = ImageFactoryStub ( )", "self . policy = unit _ test _ utils . FakePolicyEnforcer ( )", "super ( TestImagePolicy , self ) . setUp ( )", "def test _ publicize _ image _ not _ allowed ( self ) :", "rules = { `` publicize _ image `` : False }", "self . policy . set _ rules ( rules )", "image = glance . api . policy . ImageProxy ( self . image _ stub , { } , self . policy )", "self . assertRaises ( exception . Forbidden ,", "setattr , image , ' visibility ' , ' public ' )", "self . assertEquals ( image . visibility , ' private ' )", "def test _ publicize _ image _ allowed ( self ) :", "rules = { `` publicize _ image `` : True }", "self . policy . set _ rules ( rules )", "image = glance . api . policy . ImageProxy ( self . image _ stub , { } , self . policy )", "image . visibility = ' public '", "self . assertEquals ( image . visibility , ' public ' )", "def test _ delete _ image _ not _ allowed ( self ) :", "rules = { `` delete _ image `` : False }", "self . policy . set _ rules ( rules )", "image = glance . api . policy . ImageProxy ( self . image _ stub , { } , self . policy )", "self . assertRaises ( exception . Forbidden , image . delete )", "self . assertEquals ( image . status , ' active ' )", "def test _ delete _ image _ allowed ( self ) :", "rules = { `` delete _ image `` : True }", "self . policy . set _ rules ( rules )", "image = glance . api . policy . ImageProxy ( self . image _ stub , { } , self . policy )", "image . delete ( )", "self . assertEquals ( image . status , ' deleted ' )", "def test _ get _ image _ not _ allowed ( self ) :", "rules = { `` get _ image `` : False }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "self . assertRaises ( exception . Forbidden , image _ repo . get )", "def test _ get _ image _ allowed ( self ) :", "rules = { `` get _ image `` : True }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "output = image _ repo . get ( )", "self . assertTrue ( isinstance ( output , glance . api . policy . ImageProxy ) )", "self . assertEqual ( output . _ image , ' image _ from _ get ' )", "def test _ get _ images _ not _ allowed ( self ) :", "rules = { `` get _ images `` : False }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "self . assertRaises ( exception . Forbidden , image _ repo . list )", "def test _ get _ images _ allowed ( self ) :", "rules = { `` get _ image `` : True }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "images = image _ repo . list ( )", "for i , image in enumerate ( images ) :", "self . assertTrue ( isinstance ( image , glance . api . policy . ImageProxy ) )", "self . assertEqual ( image . _ image , ' image _ from _ list _ % d ' % i )", "output = image _ repo . get ( )", "def test _ modify _ image _ not _ allowed ( self ) :", "rules = { `` modify _ image `` : False }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "self . assertRaises ( exception . Forbidden , image _ repo . save )", "def test _ modify _ image _ allowed ( self ) :", "rules = { `` modify _ image `` : True }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "image _ repo . save ( )", "def test _ add _ image _ not _ allowed ( self ) :", "rules = { `` add _ image `` : False }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "self . assertRaises ( exception . Forbidden , image _ repo . add )", "def test _ add _ image _ allowed ( self ) :", "rules = { `` add _ image `` : True }", "self . policy . set _ rules ( rules )", "image _ repo = glance . api . policy . ImageRepoProxy ( { } , self . policy ,", "self . image _ repo _ stub )", "image _ repo . add ( )", "def test _ new _ image _ visibility ( self ) :", "rules = { ' publicize _ image ' : False }", "self . policy . set _ rules ( rules )", "image _ factory = glance . api . policy . ImageFactoryProxy (", "self . image _ factory _ stub , { } , self . policy )", "self . assertRaises ( exception . Forbidden , image _ factory . new _ image ,", "visibility = ' public ' )", "def test _ new _ image _ visibility _ public _ allowed ( self ) :", "rules = { ' publicize _ image ' : True }", "self . policy . set _ rules ( rules )", "image _ factory = glance . api . policy . ImageFactoryProxy (", "self . image _ factory _ stub , { } , self . policy )", "image _ factory . new _ image ( visibility = ' public ' )", ],"removed_code":[]},],]